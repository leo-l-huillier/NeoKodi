

// ---------------------------------------------------------
// FILE: ./config.json
// ---------------------------------------------------------
{
  "media_path": "E:\\game\\Projet Pro\\NeoKodi"
}

// ---------------------------------------------------------
// FILE: ./db/sources.json
// ---------------------------------------------------------
{
  "sources": [],
  "music_sources": [
    {
      "path": "E:\\game\\Projet Pro\\NeoKodi"
    }
  ],
  "video_sources": [
    {
      "path": "E:\\game\\Projet Pro\\NeoKodi"
    }
  ],
  "image_sources": [
    {
      "path": "E:\\game\\Projet Pro\\NeoKodi"
    }
  ]
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/Cargo.toml
// ---------------------------------------------------------
[package]
name = "EpiKodi"
version = "0.1.0"
edition = "2021"

[dependencies]
dioxus = { version = "0.5", features = ["desktop", "router", "hooks"] }
dioxus-desktop = "0.5"

# Tes autres libs
plugin-api = { path = "../plugin_api" } 
libloading = "0.8"
rodio = "0.21.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
lofty = "0.22.4"
rusqlite = { version = "0.31", features = ["bundled"] }
tokio = { version = "1", features = ["full"] }
base64 = "0.21"
warp = "0.3"
rfd = "0.14"
directories = "5.0"
once_cell = "1.18"
dirs = "5.0"
reqwest = { version = "0.11", features = ["blocking"] }
chrono = "0.4.43"
urlencoding = "2.1"
lazy_static = "1.4.0"
rand = "0.8.0"


// ---------------------------------------------------------
// FILE: ./EpiKodi/config.json
// ---------------------------------------------------------
{
  "media_path": "E:\\game\\Projet Pro\\NeoKodi\\EpiKodi"
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/db/sources.json
// ---------------------------------------------------------
{
  "sources": [],
  "music_sources": [
    {
      "path": "C:\\Users\\Pier-Alexandre\\OneDrive\\Bureau\\NeoKodi\\EpiKodi"
    },
    {
      "path": "E:\\game\\Projet Pro\\NeoKodi\\EpiKodi"
    }
  ],
  "video_sources": [
    {
      "path": "C:\\Users\\Pier-Alexandre\\OneDrive\\Bureau\\NeoKodi\\EpiKodi"
    },
    {
      "path": "E:\\game\\Projet Pro\\NeoKodi\\EpiKodi"
    }
  ],
  "image_sources": [
    {
      "path": "C:\\Users\\Pier-Alexandre\\OneDrive\\Bureau\\NeoKodi\\EpiKodi"
    },
    {
      "path": "E:\\game\\Projet Pro\\NeoKodi\\EpiKodi"
    }
  ]
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/config.rs
// ---------------------------------------------------------
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;
// On enl√®ve "directories" pour simplifier au max

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AppConfig {
    pub media_path: String,
}

impl AppConfig {
    pub fn load() -> Self {
        let config_path = PathBuf::from("config.json"); // <--- Juste ici, √† la racine !
        
        // Si le fichier existe, on le charge
        if config_path.exists() {
            if let Ok(content) = fs::read_to_string(&config_path) {
                if let Ok(config) = serde_json::from_str(&content) {
                    return config;
                }
            }
        }

        // Sinon, on prend le dossier courant par d√©faut
        let default_path = std::env::current_dir()
            .unwrap_or(PathBuf::from("."))
            .to_string_lossy()
            .to_string();

        let new_config = AppConfig { media_path: default_path };
        new_config.save(); // On le cr√©e tout de suite !
        new_config
    }

    pub fn save(&self) {
        let config_path = PathBuf::from("config.json");
        let json = serde_json::to_string_pretty(self).unwrap();
        let _ = fs::write(config_path, json);
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/constants/constants.rs
// ---------------------------------------------------------

/*
This file contains constant values used throughout the application
TODO: check the if there is a correct way to do that and good practices
*/

pub const SOURCE_FILE: &str = "db/sources.json";
pub const MEDIA_DB_FILE: &str = "db/library.db";

pub const DEBUG: bool = true;
pub const LOG_FILE: &str = "epikodi.log";
pub const LOG_FILE_MEDIA_ITEMS: &str = "media_items.log";
pub const LOG_IN_CONSOLE: bool = false;

pub const AUDIO_EXTS: [&str; 5] = ["mp3", "wav", "flac", "ogg", "mp4"];
pub const VIDEO_EXTS: [&str; 4] = ["mp4", "mkv", "avi", "mov"];
pub const IMAGE_EXTS: [&str; 4] = ["jpg", "png", "bmp", "gif"];

pub const PLUGIN_DIR: &str = "./plugins/";
pub const PLUGIN_EXT: &str = if cfg!(target_os = "windows") {
    "dll"
} else if cfg!(target_os = "macos") {
    "dylib"
} else {
    "so"
};

// Media status constants
pub const NOT_STARTED: i32 = 0;
pub const PLAYING: i32 = 1;
pub const FINISHED: i32 = 2;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/constants/mod.rs
// ---------------------------------------------------------
#![allow(non_snake_case)]

pub mod constants;
pub use constants::*;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/database/db.rs
// ---------------------------------------------------------
/*

*/

use rusqlite::{Connection, Result};

use crate::library::media_library::ScannedMedia;
use crate::media::data::MediaType;
use std::fs;
use std::path::Path;

#[derive(Debug)]
pub struct MediaRow {
    pub id: i64,
    pub path: String,
    pub title: Option<String>,
    pub duration: Option<f32>,
    pub media_type: MediaType,
    pub last_position: f32,
}

pub struct DB {
    pub conn: Connection,
    pub media_rows: Vec<MediaRow>,
}


impl DB {
    pub fn new() -> Self {
        if !Path::new("db").exists() {
            println!("üìÅ Dossier 'db' introuvable, cr√©ation automatique...");
            fs::create_dir("db").expect("Impossible de cr√©er le dossier 'db'");
        }
        
        DB {
            conn: Connection::open("db/library.db").unwrap(),
            media_rows: Vec::new(),
        }
    }

    pub fn clear_all_media(&self) -> Result<(), rusqlite::Error> {
        self.conn.execute("DELETE FROM media", [])?;
        println!("üóëÔ∏è BASE DE DONN√âES VID√âE");
        Ok(())
    }

    //TODO: check if this is a corrct/clean way to do this
    pub fn init_db(&mut self) -> Result<()> {
        self.conn.execute(
            "CREATE TABLE IF NOT EXISTS artist_metadata (
                id INTEGER PRIMARY KEY,
                artist_name TEXT UNIQUE NOT NULL,
                info TEXT,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
            )",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS media (
                    id INTEGER PRIMARY KEY,
                    path TEXT UNIQUE NOT NULL,
                    title TEXT,
                    duration REAL,
                    media_type TEXT,
                    status INTEGER DEFAULT 0,
                    time_stop FLOAT DEFAULT 0.0
                )
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS tags (
                    id INTEGER PRIMARY KEY,
                    name TEXT UNIQUE NOT NULL
                );
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS media_tags (
                    media_id INTEGER NOT NULL,
                    tag_id INTEGER NOT NULL,
                    PRIMARY KEY (media_id, tag_id),
                    FOREIGN KEY (media_id) REFERENCES media(id) ON DELETE CASCADE,
                    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
                );
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS playlists (
                    id INTEGER PRIMARY KEY,
                    name TEXT NOT NULL UNIQUE COLLATE NOCASE
                );
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS playlist_items (
                    playlist_id INTEGER NOT NULL,
                    media_id INTEGER NOT NULL,
                    position INTEGER DEFAULT 0,
                    PRIMARY KEY (playlist_id, media_id),
                    FOREIGN KEY (playlist_id) REFERENCES playlists(id) ON DELETE CASCADE,
                    FOREIGN KEY (media_id) REFERENCES media(id) ON DELETE CASCADE
                );
            ",
            [],
        )?;
        Ok(())
    }

    //status : 0 = not started, 1 = playing, 2 = finished
    pub fn update_media_status_and_time(&mut self, media_id: i64, status: i32, time_stop: f64, duration: f32) -> Result<()> {
        self.conn.execute(
            "
                UPDATE media
                SET status = ?1, time_stop = ?2, duration = ?3
                WHERE id = ?4
            ",
            (status, time_stop, duration, media_id),
        )?;
        Ok(())
    }
    //========MEDIA TABLE METHODS========

    pub fn insert_media(&mut self, path: &str, title: &str, duration: f32, media_type: &str) -> Result<()> {
        self.conn.execute(
            "
                INSERT OR IGNORE INTO media (path, title, duration, media_type)
                VALUES (?1, ?2, ?3, ?4)
            ",
            (path, title, duration, media_type),
        )?;
        Ok(())
    }

    pub fn get_all_media(&mut self) -> Result<&Vec<MediaRow>> {

        let mut stmt = self.conn.prepare(
            "SELECT id, path, title, duration, media_type, time_stop FROM media"
        )?;

        let rows = stmt.query_map([], |row| {
            Ok(MediaRow {
                id: row.get(0)?,
                path: row.get(1)?,
                title: row.get(2)?,
                duration: row.get(3)?,
                media_type: MediaType::from_db(&row.get::<_, String>(4)?).unwrap(),
                last_position: row.get(5)?,
            })
        })?;

        for r in rows {
            //println!("id: {}", r.as_ref().unwrap().id);
           self.media_rows.push(r?);
        }
        Ok(&self.media_rows)
    }


    pub fn print_media_rows(&mut self) {
        //println!("{:#?}", self.media_rows);

        for media in &self.media_rows {
            println!("ID: {}, Path: {}, Title: {:?}, Duration: {:?}, Type: {:?}, Last Position: {}",
                media.id, media.path, media.title, media.duration, media.media_type, media.last_position);
        }
    }

    pub fn upsert_media(&mut self, media: &ScannedMedia) -> rusqlite::Result<()> {
        self.conn.execute(
            "
            INSERT INTO media (path, title, duration, media_type)
            VALUES (?1, ?2, ?3, ?4)
            ON CONFLICT(path) DO UPDATE SET
                title = excluded.title,
                duration = CASE WHEN excluded.duration > 0 THEN excluded.duration ELSE media.duration END,
                media_type = excluded.media_type
            ",
            (
                &media.path,
                &media.name,
                media.duration,
                &media.media_type.to_string(),
            ),
        )?;
        Ok(())
    }

    pub fn upsert_media_from_scan(&mut self, scanned_media: Vec<ScannedMedia>) -> rusqlite::Result<()> {
        let tx = self.conn.transaction()?;
        {
            let mut stmt = tx.prepare(
                "
                INSERT INTO media (path, title, duration, media_type)
                VALUES (?1, ?2, ?3, ?4)
                ON CONFLICT(path) DO UPDATE SET
                    title = excluded.title,
                    duration = CASE WHEN excluded.duration > 0 THEN excluded.duration ELSE media.duration END,
                    media_type = excluded.media_type
                ",
            )?;

            for media in scanned_media {
                stmt.execute((
                    &media.path,
                    &media.name,
                    media.duration,
                    &media.media_type.to_string(),
                ))?;
            }
        }
        tx.commit()?;
        Ok(())
    }

    pub fn cleanup_missing_media(&mut self, scanned_media: Vec<ScannedMedia>) -> rusqlite::Result<()> {

        let scanned_paths: Vec<String> = scanned_media.iter().map(|m| m.path.clone()).collect();
        let placeholders = scanned_paths.iter().map(|_| "?").collect::<Vec<_>>().join(", ");
        let sql = format!("DELETE FROM media WHERE path NOT IN ({})", placeholders);

        let mut stmt = self.conn.prepare(&sql)?;
        let params: Vec<&dyn rusqlite::ToSql> = scanned_paths.iter().map(|p| p as &dyn rusqlite::ToSql).collect();
        stmt.execute(rusqlite::params_from_iter(params))?;
        Ok(())
    }

    //========= TAGS TABLE METHODS========

    pub fn get_or_create_tag(&mut self, name: &str) -> rusqlite::Result<i64> {
        self.conn.execute(
            "INSERT OR IGNORE INTO tags (name) VALUES (?1)",
            [name],
        )?;

        self.conn.query_row(
            "SELECT id FROM tags WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }

    //TODO: y a pas de gestion d'erreur ici c'est important √† corriger
    pub fn get_tag_id(&mut self, name: &str) -> rusqlite::Result<i64> {
        self.conn.query_row(
            "SELECT id FROM tags WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }

    pub fn get_all_tags(&mut self) -> rusqlite::Result<Vec<(i64, String)>> {
        let mut stmt = self.conn.prepare(
            "
                SELECT id, name
                FROM tags
                ORDER BY name COLLATE NOCASE ASC
            ",
        )?;

        let rows = stmt.query_map([], |row| {
            Ok((row.get(0)?, row.get(1)?))
        })?;

        Ok(rows.filter_map(Result::ok).collect())
    }


    pub fn add_tag_to_media(&mut self, media_id: i64, tag_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
                INSERT OR IGNORE INTO media_tags (media_id, tag_id)
                VALUES (?1, ?2)
            ",
            (media_id, tag_id),
        )?;
        Ok(())
    }

    pub fn remove_tag_from_media(&mut self, media_id: i64, tag_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
                DELETE FROM media_tags
                WHERE media_id = ?1 AND tag_id = ?2
            ",
            (media_id, tag_id),
        )?;
        Ok(())
    }

    pub fn remove_tag(&mut self, tag_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
                DELETE FROM media_tags
                WHERE tag_id = ?1
            ",
            [tag_id],
        )?;
        self.conn.execute(
            "
                DELETE FROM tags
                WHERE id = ?1
            ",
            [tag_id],
        )?;
        Ok(())
    }


    pub fn get_media_by_tag(&mut self, tag_name: &str) -> rusqlite::Result<Vec<i64>> {
        let mut stmt = self.conn.prepare(
            "
                SELECT media.id
                FROM media
                JOIN media_tags ON media.id = media_tags.media_id
                JOIN tags ON tags.id = media_tags.tag_id
                WHERE tags.name = ?1
            ",
        )?;

        let rows = stmt.query_map([tag_name], |row| row.get(0))?;

        Ok(rows.filter_map(Result::ok).collect())
    }

    //========= PLAYLIST TABLE METHODS========


    pub fn create_playlist(&mut self, name: &str) -> rusqlite::Result<i64> {

        self.conn.execute(
            "INSERT OR IGNORE INTO playlists (name) VALUES (?1)",
            [name],
        )?;

        self.conn.query_row(
            "SELECT id FROM playlists WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }

    pub fn delete_playlist(&mut self, playlist_id: i64) -> rusqlite::Result<()> {

        self.conn.execute(
            "DELETE FROM playlist_items WHERE playlist_id = ?1",
            [playlist_id],
        )?;
        self.conn.execute(
            "DELETE FROM playlists WHERE id = ?1",
            [playlist_id],
        )?;
        Ok(())
    }

    pub fn add_media_to_playlist(&mut self, media_id: i64, playlist_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
            INSERT OR REPLACE INTO playlist_items
            (playlist_id, media_id)
            VALUES (?1, ?2)
            ",
            (playlist_id, media_id),
        )?;
        Ok(())
    }

    pub fn remove_media_from_playlist(&mut self, media_id: i64, playlist_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
            DELETE FROM playlist_items
            WHERE playlist_id = ?1 AND media_id = ?2
            ",
            (playlist_id, media_id),
        )?;
        Ok(())
    }

    pub fn get_media_from_playlist(&mut self, playlist_id: i64) -> rusqlite::Result<Vec<i64>> {
        let mut stmt = self.conn.prepare(
            "
                SELECT media_id
                FROM playlist_items
                WHERE playlist_id = ?1
                ORDER BY position ASC
            ",
        )?;

        let rows = stmt.query_map([playlist_id], |row| row.get(0))?;

        Ok(rows.filter_map(Result::ok).collect())
    }
    
    //ORDER BY position ASC
    pub fn get_playlist_id(&mut self, name: &str) -> rusqlite::Result<i64> {
        self.conn.query_row(
            "SELECT id FROM playlists WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }

    pub fn get_all_playlists(&mut self) -> rusqlite::Result<Vec<(i64, String)>> {
        let mut stmt = self.conn.prepare(
            "
                SELECT id, name
                FROM playlists
                ORDER BY name COLLATE NOCASE ASC
            ",
        )?;

        let rows = stmt.query_map([], |row| {
            Ok((row.get(0)?, row.get(1)?))
        })?;

        Ok(rows.filter_map(Result::ok).collect())
    }

    //========= PLAYLIST TABLE METHODS========

    pub fn save_artist_metadata(&self, name: &str, info: &str) -> Result<()> {
        self.conn.execute(
            "INSERT OR REPLACE INTO artist_metadata (artist_name, info, last_updated) VALUES (?1, ?2, CURRENT_TIMESTAMP)",
            (name, info),
        )?;
        Ok(())
    }

    pub fn get_all_artist_metadata(&self) -> Result<Vec<String>> {
        let mut stmt = self.conn.prepare("SELECT info FROM artist_metadata ORDER BY last_updated ASC")?;
        let rows = stmt.query_map([], |row| row.get(0))?;
        Ok(rows.filter_map(|r| r.ok()).collect())
    }








    //========TESTING PURPOSES ONLY========

    pub fn clear_media_table(&mut self) -> Result<()> {
        self.conn.execute(
            "DELETE FROM media",
            [],
        )?;
        Ok(())
    }

    pub fn add_sample_data(&mut self) -> Result<()> {
        self.insert_media("path/to/media1.mp4", "Sample Media 1", 300.0, "video")?;
        self.insert_media("path/to/media2.mp3", "Sample Media 2", 200.0, "audio")?;
        self.insert_media("path/to/media3.jpg", "Sample Media 3", 0.0, "image")?;
        Ok(())
    }

    

} 












#[cfg(test)]
mod tests {
    use super::*;
    use rusqlite::Connection;

    fn create_test_db() -> DB {
        let conn = Connection::open_in_memory().unwrap();
        let mut db = DB {
            conn,
            media_rows: Vec::new(),
        };
        db.init_db().unwrap();
        db
    }

    #[test]
    fn test_init_db() {
        let mut db = create_test_db();

        assert!(db.init_db().is_ok());
    }

    #[test]
    fn test_insert_media() {
        let mut db = create_test_db();

        assert!(db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").is_ok());
    }

    #[test]
    fn test_get_all_media() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        
        let media = db.get_all_media().unwrap();

        assert_eq!(media.len(), 1);
        assert_eq!(media[0].path, "path/to/video.mp4");
    }

    #[test]
    fn test_get_or_create_tag() {
        let mut db = create_test_db();
        let tag_id1 = db.get_or_create_tag("action").unwrap();
        let tag_id2 = db.get_or_create_tag("action").unwrap();

        assert_eq!(tag_id1, tag_id2);
    }

    #[test]
    fn test_get_tag_id() {
        let mut db = create_test_db();
        db.get_or_create_tag("comedy").unwrap();

        let tag_id = db.get_tag_id("comedy").unwrap();

        assert!(tag_id > 0);
    }

    #[test]
    fn test_add_tag_to_media() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        
        let tag_id = db.get_or_create_tag("action").unwrap();
        
        assert!(db.add_tag_to_media(1, tag_id).is_ok());
    }

    #[test]
    fn test_get_media_by_tag() {
        let mut db = create_test_db();
        db.insert_media("path/to/video1.mp4", "Video 1", 120.0, "video").unwrap();
        db.insert_media("path/to/video2.mp4", "Video 2", 150.0, "video").unwrap();
        
        let tag_id = db.get_or_create_tag("action").unwrap();
        db.add_tag_to_media(1, tag_id).unwrap();
        
        let media = db.get_media_by_tag("action").unwrap();
        
        assert_eq!(media.len(), 1);
        assert_eq!(media[0], 1);
    }

    #[test]
    fn test_create_playlist() {
        let mut db = create_test_db();
        let playlist_id = db.create_playlist("My Playlist").unwrap();
        
        assert!(playlist_id > 0);
    }

    #[test]
    fn test_add_media_to_playlist() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        let playlist_id = db.create_playlist("My Playlist").unwrap();
        
        assert!(db.add_media_to_playlist(1, playlist_id).is_ok());
    }

    #[test]
    #[ignore]
    fn test_get_media_from_playlist() {
        let mut db = create_test_db();
        db.insert_media("path/to/video1.mp4", "Video 1", 120.0, "video").unwrap();
        db.insert_media("path/to/video2.mp4", "Video 2", 150.0, "video").unwrap();
        
        let playlist_id = db.create_playlist("My Playlist").unwrap();
        db.add_media_to_playlist(1, playlist_id).unwrap();
        db.add_media_to_playlist(2, playlist_id).unwrap();
        
        let media = db.get_media_from_playlist(playlist_id).unwrap();
        
        assert_eq!(media.len(), 2);
    }

    #[test]
    fn test_get_playlist_id() {
        let mut db = create_test_db();
        db.create_playlist("Test Playlist").unwrap();
        let id = db.get_playlist_id("Test Playlist").unwrap();

        assert!(id > 0);
    }

    #[test]
    fn test_clear_media_table() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        
        assert!(db.clear_media_table().is_ok());
        let media = db.get_all_media().unwrap();
        
        assert_eq!(media.len(), 0);
    }
}




// ---------------------------------------------------------
// FILE: ./EpiKodi/src/database/mod.rs
// ---------------------------------------------------------
pub mod db; 

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/gui/init.rs
// ---------------------------------------------------------
use dioxus::prelude::*;

use std::sync::{mpsc, OnceLock};
use tokio::sync::broadcast;

use crate::threading::media_thread::launch_media_thread;
use crate::threading::command::{Command, Event};

use crate::media::data::{MediaInfo, MediaType};
use crate::gui::pages::PluginSearchResult;
use crate::gui::route::Route;

use crate::config::AppConfig;
use std::cell::RefCell;
use std::rc::Rc;
use std::path::PathBuf;
use std::time::Duration;
use crate::iptv::parser::TVChannel;


pub static RELOAD_SIGNAL: OnceLock<broadcast::Sender<()>> = OnceLock::new();

struct Backend {
    tx: mpsc::Sender<Command>,
    rx: RefCell<Option<mpsc::Receiver<Event>>>,
}

// === COMPOSANT RACINE (D√âPLAC√â) ===
pub fn App() -> Element {
    let backend_channels = use_hook(|| {
        let (cmd_tx, cmd_rx) = mpsc::channel::<Command>();
        let (evt_tx, evt_rx) = mpsc::channel::<Event>();
        
        launch_media_thread(cmd_rx, evt_tx);

        let config = AppConfig::load();
        let root_path = PathBuf::from(config.media_path);
        
        // Initialisation scan
        let _ = cmd_tx.send(Command::AddSource(root_path.clone(), MediaType::Video));
        let _ = cmd_tx.send(Command::AddSource(root_path.clone(), MediaType::Audio));
        let _ = cmd_tx.send(Command::AddSource(root_path, MediaType::Image));
        let _ = cmd_tx.send(Command::GetAllMedia());
        let _ = cmd_tx.send(Command::GetAllPlaylists());
        let _ = cmd_tx.send(Command::GetPluginHistory);
        
        Rc::new(Backend { tx: cmd_tx, rx: RefCell::new(Some(evt_rx)) })
    });

    use_context_provider(|| backend_channels.tx.clone());
    
    // √âtats globaux
    let mut media_list = use_context_provider(|| Signal::new(Vec::<MediaInfo>::new()));

    // Pour recevoir le contenu d'une playlist
    let mut playlists = use_context_provider(|| Signal::new(Vec::<(i64, String)>::new()));
    let mut loaded_ids = use_context_provider(|| Signal::new(Vec::<i64>::new()));
    
    // Plugin Result
    let mut plugin_result = use_context_provider(|| Signal::new(Vec::<String>::new()));
    
    let mut root_path_signal = use_context_provider(|| Signal::new(String::new()));
    let current_config = AppConfig::load();
    root_path_signal.set(current_config.media_path);

    if let Some(tx) = RELOAD_SIGNAL.get() {
        use_context_provider(|| tx.clone());
    }

    let mut iptv_loading = use_context_provider(|| Signal::new(false)); 
    let mut iptv_channels = use_context_provider(|| Signal::new(Vec::<TVChannel>::new()));

    // BOUCLE D'√âV√âNEMENTS
    use_coroutine(|_: UnboundedReceiver<()>| {
        let backend = backend_channels.clone();
        async move {
            let mut rx_opt = backend.rx.borrow_mut();
            if let Some(rx) = rx_opt.take() {
                drop(rx_opt);
                loop {
                    while let Ok(msg) = rx.try_recv() {
                        match msg {
                            Event::MediaList(list) => { media_list.set(list); },

                            Event::PlaylistList(list) => { playlists.set(list); },
                            Event::IDList(ids) => { loaded_ids.set(ids); },
                            
                            Event::PluginDataReceived(info) => {
                                plugin_result.write().insert(0, info);
                            },

                            Event::NowPlaying(id) => println!("‚ñ∂Ô∏è Lecture ID: {}", id),
                            Event::Info(info) => println!("‚ÑπÔ∏è Info: {:?}", info.title),
                            Event::M3UList(channels) => {
                                iptv_channels.set(channels);
                                iptv_loading.set(false);
                            },
                            _ => {} 
                        }
                    }
                    tokio::time::sleep(Duration::from_millis(50)).await;
                }
            }
        }
    });

    rsx! { Router::<Route> {} }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/gui/layout.rs
// ---------------------------------------------------------
use dioxus::prelude::*;
use super::route::Route;       // On a besoin de conna√Ætre les routes pour les liens
use super::style::GLOBAL_STYLE; // On importe le style

pub fn AppLayout() -> Element {
    rsx! {
        style { "{GLOBAL_STYLE}" }
        div { class: "container",
            // -------- MENU LATERAL --------
            nav { class: "sidebar",
                Link { to: Route::Home {}, class: "nav-item", "Accueil" }
                Link { to: Route::Iptv {}, class: "nav-item", "Iptv" }
                Link { to: Route::Videos {}, class: "nav-item", "Vid√©os" }
                Link { to: Route::Series {}, class: "nav-item", "S√©ries" }
                Link { to: Route::Music {}, class: "nav-item", "Musique" }
                Link { to: Route::Images {}, class: "nav-item", "Images" }
                Link { to: Route::Plugins {}, class: "nav-item", "Add-ons" }
                Link { to: Route::Settings {}, class: "nav-item", "Param√®tres" }
            }

            // -------- ZONE CONTENU DYNAMIQUE --------
            main { class: "content",
                Outlet::<Route> {}
            }
        }
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/gui/mod.rs
// ---------------------------------------------------------
pub mod route;
pub mod layout;
pub mod pages;
pub mod style;
pub mod init;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/gui/pages.rs
// ---------------------------------------------------------
use dioxus::prelude::*;
use super::route::Route;
use crate::threading::command::Command;
use crate::media::data::{MediaType, MediaInfo};
use std::fs; 
use base64::{Engine as _, engine::general_purpose};
use std::path::PathBuf;
use crate::library::sources::LibraryConfig;
use crate::constants::SOURCE_FILE;
use urlencoding::encode;
use rand::Rng;
use std::time::Duration;

// üëá STRUCTURE POUR LES PLUGINS
#[derive(Clone, PartialEq)]
pub struct PluginSearchResult {
    pub text: String,
}

#[derive(PartialEq, Clone, Copy, Debug)]
enum PlayMode {
    StopAtEnd,
    Sequential,
    Random,
    Loop,
}

impl PlayMode {
    fn next(&self) -> Self {
        match self {
            PlayMode::StopAtEnd => PlayMode::Sequential,
            PlayMode::Sequential => PlayMode::Random,
            PlayMode::Random => PlayMode::Loop,
            PlayMode::Loop => PlayMode::StopAtEnd,
        }
    }

    fn icon(&self) -> &'static str {
        match self {
            PlayMode::StopAtEnd => "üõë Stop",
            PlayMode::Sequential => "‚û°Ô∏è Suite",
            PlayMode::Random => "üîÄ Hasard",
            PlayMode::Loop => "üîÅ Boucle",
        }
    }
    
    fn color(&self) -> &'static str {
        match self {
            PlayMode::StopAtEnd => "#7f8c8d",
            PlayMode::Sequential => "#3498db",
            PlayMode::Random => "#9b59b6",
            PlayMode::Loop => "#e67e22",
        }
    }
}

fn make_url(full_path: &str, _root_path: &str) -> String {
    // 1. On normalise les slashs (Windows utilise \, le web utilise /)
    let clean_path = full_path.replace("\\", "/");

    // 2. On g√®re les lettres de lecteur (Ex: "C:/Films/Vacances.mp4")
    if let Some(colon_idx) = clean_path.find(':') {
        if colon_idx == 1 { 
            // On r√©cup√®re la lettre "c"
            let drive_letter = &clean_path[0..1].to_lowercase();
            
            // On prend tout ce qu'il y a apr√®s "C:/"
            // Attention : on v√©rifie qu'on ne d√©passe pas la taille de la string
            let path_after_drive = if clean_path.len() > 3 {
                &clean_path[3..]
            } else {
                ""
            };

            // 3. LA CL√â DU SUCC√àS : On encode chaque dossier s√©par√©ment
            // Si on encode tout d'un coup, les "/" deviennent "%2F" et le serveur ne trouve pas le dossier.
            let encoded_parts: Vec<String> = path_after_drive.split('/')
                .map(|part| urlencoding::encode(part).to_string())
                .collect();
            
            // On reconstruit l'URL propre
            let url = format!("http://127.0.0.1:3030/drives/{}/{}", drive_letter, encoded_parts.join("/"));
            
            // Petit log pour v√©rifier
            println!("üîó URL FIX√âE : {} -> {}", full_path, url);
            return url;
        }
    }

    // Cas de secours (si le chemin n'a pas de lettre de lecteur, rare sous Windows absolu)
    let encoded_path = urlencoding::encode(&clean_path).to_string();
    format!("http://127.0.0.1:3030/media/{}", encoded_path)
}

// --- ACCUEIL ---
#[component]
pub fn Home() -> Element {
    rsx! {
        div { class: "container",
            div { style: "display: flex; flex-direction: column; align-items: center; justify-content: center; padding-top: 50px;",
                h1 { style: "font-size: 4rem; margin-bottom: 50px; color: #007acc; text-transform: uppercase; letter-spacing: 5px;", "NeoKodi" }
                
                div { class: "media-grid", style: "width: 100%; max-width: 900px;",
                    Link { to: Route::Videos {}, class: "media-card", div { class: "card-icon", "üé¨" } div { class: "card-text", "Vid√©os" } }
                    Link { to: Route::Images {}, class: "media-card", div { class: "card-icon", "üñºÔ∏è" } div { class: "card-text", "Images" } }
                    Link { to: Route::Music {}, class: "media-card", div { class: "card-icon", "üéµ" } div { class: "card-text", "Musique" } }
                    Link { to: Route::Plugins {}, class: "media-card", div { class: "card-icon", "üß©" } div { class: "card-text", "Plugins" } }
                    Link { to: Route::Settings {}, class: "media-card", div { class: "card-icon", "‚öôÔ∏è" } div { class: "card-text", "Param√®tres" } }
                }
            }
        }
    }
}

#[component]
pub fn Music() -> Element {
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let list_signal = use_context::<Signal<Vec<MediaInfo>>>();
    let root_path_signal = use_context::<Signal<String>>();
    let root_path = root_path_signal();
    let plugin_history = use_context::<Signal<Vec<String>>>();
    
    // Contextes Playlist
    let mut all_playlists = use_context::<Signal<Vec<(i64, String)>>>(); // (ID, Nom)
    let mut loaded_ids_signal = use_context::<Signal<Vec<i64>>>(); // IDs de la playlist active

    // √âtats Lecture
    let mut current_audio = use_signal(|| Option::<MediaInfo>::None);
    let mut play_mode = use_signal(|| PlayMode::Sequential);
    let mut search_text = use_signal(|| String::new());
    let mut queue = use_signal(|| Vec::<MediaInfo>::new());

    // √âtats UI
    let mut show_queue_popup = use_signal(|| false);
    let mut show_playlist_manager = use_signal(|| false);
    let mut new_playlist_name = use_signal(|| String::new());
    
    // üëá NOUVEAU : Pour savoir si on est en mode "Vue Playlist"
    let mut active_playlist_name = use_signal(|| Option::<String>::None);
    
    // √âtat pour le menu "Ajouter √†..." (ID du m√©dia en cours d'ajout)
    let mut adding_media_to_playlist = use_signal(|| Option::<i64>::None);

    let tx_init = cmd_tx.clone();
    use_hook(move || { 
        if list_signal().is_empty() { tx_init.send(Command::GetAllMedia()).unwrap(); } 
        tx_init.send(Command::GetAllPlaylists()).unwrap();
        tx_init.send(Command::GetPluginHistory).unwrap();

        // üöÄ AUTO-RECHERCHE CORRIG√âE
        let list = list_signal();
        // On pr√©cise le type explicitement pour aider Rust
        let mut searched_artists = std::collections::HashSet::<String>::new();
        
        // On it√®re directement sur 'list' (pas de parenth√®ses ici !)
        for item in list.iter().filter(|i| i.media_type == MediaType::Audio) {
            if let Some(ref artist) = item.artist {
                if !searched_artists.contains(artist) {
                    let _ = tx_init.send(Command::GetArtistMetadataFromPlugin(artist.clone()));
                    searched_artists.insert(artist.clone());
                }
            }
        }
    });

    // NOTE : J'ai supprim√© le use_effect qui remplissait la queue automatiquement.
    // Maintenant, cliquer sur une playlist ne fait que FILTRER la vue.
    // Si tu veux tout jouer, tu cliques sur le premier titre affich√©.

    let css_music = "
        @keyframes scroll-text { 0% { transform: translateX(100%); } 100% { transform: translateX(-100%); } }
        .marquee-container { overflow: hidden; white-space: nowrap; width: 100%; position: relative; }
        .marquee-text { display: inline-block; animation: scroll-text 15s linear infinite; padding-left: 100%; }
        
        .audio-row:active { background-color: #333 !important; transform: scale(0.99); transition: transform 0.1s; }
        .add-queue-btn { opacity: 0.5; transition: opacity 0.2s; }
        .add-queue-btn:hover { opacity: 1; transform: scale(1.1); }
        
        .queue-popup::-webkit-scrollbar { width: 6px; }
        .queue-popup::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        .queue-popup::-webkit-scrollbar-track { background: #222; }

        .playlist-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); 
            z-index: 3000;
            display: flex; justify-content: center; align-items: center;
        }
        .playlist-modal {
            background: #1e1e1e; padding: 25px; border-radius: 12px; width: 400px;
            border: 1px solid #333; box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .pl-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; border-bottom: 1px solid #333; cursor: pointer;
        }
        .pl-item:hover { background: #2d2d2d; }
        .pl-option { padding: 8px 10px; cursor: pointer; color: white; }
        .pl-option:hover { background: #333; }
    ";

    rsx! {
        style { "{css_music}" }
        
        div { class: "container", style: "padding-bottom: 100px;",
            
            // --- TOP BAR ---
            div { class: "top-bar", 
                style: "display: flex; align-items: center; justify-content: space-between; position: relative; height: 60px; padding: 0 20px; z-index: 500; background: #121212;",
                
                div { style: "z-index: 2;", Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" } }
                
                // Bouton Gestion Playlists
                div { style: "z-index: 2; position: absolute; left: 140px;",
                    button { 
                        class: "btn-nav", 
                        style: "position: relative; transform: none; top: auto; left: auto; background: #8e44ad;",
                        onclick: move |_| show_playlist_manager.set(true),
                        "üìÇ Playlists"
                    }
                }

                // TITRE CENTRAL DYNAMIQUE
                div { 
                    style: "position: absolute; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 10px; z-index: 2;",
                    
                    if let Some(name) = active_playlist_name() {
                        // MODE PLAYLIST ACTIVE
                        span { style: "color: #2ecc71; font-weight: bold; font-size: 1.2rem;", "üìÇ {name}" }
                        button {
                            style: "background: none; border: none; color: #e74c3c; cursor: pointer; font-size: 1.2rem; padding: 0 5px;",
                            title: "Fermer la playlist",
                            onclick: move |_| {
                                active_playlist_name.set(None); // On quitte le mode playlist
                                loaded_ids_signal.write().clear(); // On vide le filtre
                            },
                            "‚úñ"
                        }
                    } else {
                        // MODE NORMAL
                        span { style: "font-weight: bold; font-size: 1.2rem;", "Musique" }
                    }
                } 
                
                div { style: "z-index: 2;",
                    input {
                        r#type: "text", placeholder: "üîç Titre...",
                        style: "padding: 8px; border-radius: 5px; border: none; background: #333; color: white; width: 250px;",
                        oninput: move |evt| search_text.set(evt.value()),
                    }
                }
            }
            
            // --- LISTE PRINCIPALE (AVEC FILTRE PLAYLIST) ---
            div { class: "audio-list",
                {list_signal().iter()
                    .filter(|i| i.media_type == MediaType::Audio)
                    // 1. Filtre Recherche
                    .filter(|i| {
                        let query = search_text().to_lowercase();
                        if query.is_empty() { return true; }
                        i.title.as_deref().unwrap_or(&i.path).to_lowercase().contains(&query)
                    })
                    // 2. Filtre Playlist (Si active)
                    .filter(|i| {
                        if active_playlist_name().is_some() {
                            loaded_ids_signal().contains(&i.id)
                        } else {
                            true
                        }
                    })
                    // 3. Mapping pour l'affichage
                    .map(|item| {
                        // Calcul du Z-Index dynamique
                        let is_menu_open = adding_media_to_playlist() == Some(item.id);
                        let z_index = if is_menu_open { 100 } else { 0 };
                        
                        rsx! {
                            div { 
                                class: "audio-row",
                                style: "cursor: pointer; transition: background 0.2s; user-select: none; display: flex; align-items: center; justify-content: space-between; padding-right: 15px; position: relative; z-index: {z_index}; overflow: visible;", 
                                
                                // Clic principal : Jouer
                                onclick: { 
                                    let track = item.clone();
                                    let i = item.id; 
                                    let tx = cmd_tx.clone();
                                    let mut history = plugin_history.clone(); // ‚úÖ On utilise le nouveau nom
                                    move |_| { 
                                        history.write().insert(0, "...".to_string()); 
                                        
                                        current_audio.set(Some(track.clone())); 
                                        tx.send(Command::Play(i)).unwrap(); 
                                        
                                        if let Some(ref artist) = track.artist {
                                            let _ = tx.send(Command::GetArtistMetadataFromPlugin(artist.clone()));
                                        }
                                    } 
                                },
                                
                                div { style: "display: flex; align-items: center; flex: 1;",
                                    div { class: "audio-icon", 
                                        if current_audio().as_ref().map(|c| c.id) == Some(item.id) { "üîä" } else { "üéµ" }
                                    }
                                    div { class: "audio-info", 
                                        div { 
                                            class: "audio-title", 
                                            style: if current_audio().as_ref().map(|c| c.id) == Some(item.id) { "color: #1db954; font-weight: bold;" } else { "" },
                                            "{item.title.as_deref().unwrap_or(&item.path)}" 
                                        } 
                                        div { 
                                            class: "audio-artist", 
                                            "{item.artist.as_deref().unwrap_or(\"Artiste inconnu\")}" 
                                        }
                                    }
                                },

                                div { style: "display: flex; gap: 10px;",
                                    // Bouton Disquette (Ajouter √† playlist)
                                    button {
                                        class: "add-queue-btn",
                                        style: "background: transparent; border: 1px solid #555; color: #f1c40f; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; display: flex; align-items: center; justify-content: center;",
                                        title: "Sauvegarder dans une playlist",
                                        onclick: {
                                            let id = item.id;
                                            move |evt: Event<MouseData>| {
                                                evt.stop_propagation(); 
                                                if adding_media_to_playlist() == Some(id) {
                                                    adding_media_to_playlist.set(None);
                                                } else {
                                                    adding_media_to_playlist.set(Some(id));
                                                }
                                            }
                                        },
                                        "üíæ"
                                    }

                                    // Bouton Plus (Ajouter √† file d'attente)
                                    button {
                                        class: "add-queue-btn",
                                        style: "background: transparent; border: 1px solid #555; color: white; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; display: flex; align-items: center; justify-content: center;",
                                        title: "Ajouter √† la file d'attente actuelle",
                                        onclick: {
                                            let track = item.clone();
                                            move |evt: Event<MouseData>| {
                                                evt.stop_propagation();
                                                queue.write().push(track.clone());
                                            }
                                        },
                                        "‚ûï"
                                    }
                                }

                                // --- POPUP MENU D√âROULANT ---
                                if is_menu_open {
                                    div {
                                        style: "position: absolute; right: 50px; top: 40px; background: #222; border: 1px solid #444; border-radius: 5px; z-index: 200; min-width: 200px; box-shadow: 0 5px 15px rgba(0,0,0,0.8);",
                                        onclick: |evt: Event<MouseData>| evt.stop_propagation(),
                                        
                                        // Zone Cr√©ation
                                        div {
                                            style: "padding: 8px; border-bottom: 1px solid #444; background: #2a2a2a;",
                                            input {
                                                r#type: "text",
                                                value: "{new_playlist_name}",
                                                placeholder: "‚ûï Cr√©er & Ajouter...",
                                                style: "width: 100%; padding: 5px; border: 1px solid #555; border-radius: 3px; background: #111; color: white; font-size: 0.8rem;",
                                                oninput: move |evt| new_playlist_name.set(evt.value()),
                                            }
                                            if !new_playlist_name().is_empty() {
                                                div {
                                                    style: "margin-top: 5px; cursor: pointer; background: #27ae60; color: white; padding: 4px; text-align: center; border-radius: 3px; font-size: 0.8rem;",
                                                    onclick: {
                                                        let mid = item.id;
                                                        let tx = cmd_tx.clone();
                                                        move |_| {
                                                            tx.send(Command::AddPlaylist(new_playlist_name())).unwrap();
                                                            tx.send(Command::GetAllPlaylists()).unwrap();
                                                            // Id√©alement on ajoute direct, mais ici on cr√©e d'abord
                                                            new_playlist_name.set(String::new());
                                                        }
                                                    },
                                                    "Cr√©er"
                                                }
                                            }
                                        }

                                        div { style: "padding: 5px 10px; color: #888; font-size: 0.7rem; text-transform: uppercase;", "Playlists existantes" }
                                        
                                        // Liste Playlists
                                        div { style: "max-height: 150px; overflow-y: auto;",
                                            for (pl_id, pl_name) in all_playlists() {
                                                div {
                                                    class: "pl-option",
                                                    onclick: {
                                                        let pid = pl_id;
                                                        let mid = item.id;
                                                        let tx = cmd_tx.clone();
                                                        move |_| {
                                                            tx.send(Command::AddMediaToPlaylist(mid, pid)).unwrap();
                                                            adding_media_to_playlist.set(None);
                                                        }
                                                    },
                                                    "üìÇ {pl_name}"
                                                }
                                            }
                                            if all_playlists().is_empty() {
                                                div { style: "padding: 10px; color: #666; font-style: italic; font-size: 0.8rem;", "Aucune playlist." }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    })
                }
            }

            // --- GESTIONNAIRE DE PLAYLISTS (MODAL) ---
            if show_playlist_manager() {
                div { class: "playlist-overlay", onclick: move |_| show_playlist_manager.set(false),
                    div { class: "playlist-modal", onclick: |evt| evt.stop_propagation(),
                        h2 { style: "margin-top: 0; color: white;", "Mes Playlists" }
                        
                        // Cr√©er nouvelle (Gros bouton)
                        div { style: "display: flex; gap: 10px; margin-bottom: 20px;",
                            input {
                                r#type: "text",
                                value: "{new_playlist_name}",
                                placeholder: "Nom de la playlist...",
                                style: "flex: 1; padding: 8px; border-radius: 5px; border: 1px solid #444; background: #2d2d2d; color: white;",
                                oninput: move |evt| new_playlist_name.set(evt.value()),
                            }
                            button {
                                class: "btn-nav",
                                style: "position: relative; transform: none; top: auto; left: auto; background: #27ae60;",
                                onclick: {
                                    let tx = cmd_tx.clone();
                                    move |_| {
                                        if !new_playlist_name().is_empty() {
                                            tx.send(Command::AddPlaylist(new_playlist_name())).unwrap();
                                            tx.send(Command::GetAllPlaylists()).unwrap();
                                            new_playlist_name.set(String::new());
                                        }
                                    }
                                },
                                "Cr√©er"
                            }
                        }

                        // Liste pour Ouvrir/Supprimer
                        div { style: "max-height: 300px; overflow-y: auto;",
                            for (id, name) in all_playlists() {
                                div { class: "pl-item",
                                    
                                    // üëá C'EST CE BOUTON QUI DECONNE ACTUELLEMENT
                                    div { 
                                        style: "flex: 1;",
                                        onclick: {
                                            let pid = id;
                                            let pname = name.clone(); // Clone pour le signal
                                            let tx = cmd_tx.clone();
                                            move |_| {
                                                println!("üñ±Ô∏è [FRONT] Clic sur ouvrir playlist ID: {}", pid); // MOCHARD FRONTEND
                                                
                                                // 1. Envoyer l'ordre au backend
                                                match tx.send(Command::GetMediaFromPlaylist(pid)) {
                                                    Ok(_) => println!("‚úÖ [FRONT] Commande envoy√©e !"),
                                                    Err(e) => println!("‚ùå [FRONT] Erreur envoi commande : {}", e),
                                                }

                                                // 2. Activer le mode visuel
                                                active_playlist_name.set(Some(pname.clone()));
                                                
                                                // 3. Fermer la fen√™tre
                                                show_playlist_manager.set(false);
                                            }
                                        },
                                        "üìÇ {name}" 
                                    },
                                    
                                    // SUPPRIMER (Celui-ci marchait peut-√™tre d√©j√†, mais on le garde propre)
                                    button {
                                        style: "background: none; border: none; color: #c0392b; cursor: pointer; font-weight: bold;",
                                        onclick: {
                                            let pid = id;
                                            let tx = cmd_tx.clone();
                                            move |evt: Event<MouseData>| {
                                                evt.stop_propagation();
                                                tx.send(Command::DeletePlaylist(pid)).unwrap();
                                                tx.send(Command::GetAllPlaylists()).unwrap();
                                            }
                                        },
                                        "üóëÔ∏è"
                                    }
                                }
                            }
                            if all_playlists().is_empty() {
                                div { style: "color: #777; text-align: center; padding: 20px;", "Aucune playlist cr√©√©e." }
                            }
                        }

                        div { style: "margin-top: 20px; text-align: right;",
                            button { 
                                class: "btn-nav", 
                                style: "position: relative; transform: none; top: auto; left: auto; background: #444;",
                                onclick: move |_| show_playlist_manager.set(false),
                                "Fermer" 
                            }
                        }
                    }
                }
            }

            // --- LECTEUR AUDIO (FIXED BOTTOM) ---
            if let Some(track) = current_audio() {
                div { 
                    style: "position: fixed; bottom: 0; left: 0; width: 100%; height: 90px; background: #181818; border-top: 1px solid #282828; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 1000; box-shadow: 0 -5px 15px rgba(0,0,0,0.5);",
                    
                    // Partie Gauche (Infos)
                    div { style: "width: 25%; position: relative;",
                        div { class: "marquee-container",
                            div { class: "marquee-text", style: "font-weight: bold; font-size: 1.1rem;",
                                "{track.title.as_deref().unwrap_or(&track.path)}"
                            }
                        }
                        if !queue().is_empty() {
                            div { 
                                style: "display: inline-block; cursor: help; position: relative;",
                                onmouseenter: move |_| show_queue_popup.set(true),
                                onmouseleave: move |_| show_queue_popup.set(false),
                                div { style: "color: #3498db; font-size: 0.8rem; margin-top: 4px; font-weight: bold;", "‚è≠Ô∏è En attente : {queue().len()} titre(s)" }
                                if show_queue_popup() {
                                    div {
                                        class: "queue-popup",
                                        style: "position: absolute; bottom: 130%; left: 0; width: 300px; max-height: 400px; overflow-y: auto; background: #282828; border: 1px solid #444; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.8); padding: 10px; z-index: 2000;",
                                        h4 { style: "margin: 0 0 10px 0; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px;", "File d'attente" }
                                        for (idx, song) in queue().iter().enumerate() {
                                            div { 
                                                style: "padding: 8px; border-bottom: 1px solid #333; font-size: 0.9rem; color: #ccc; display: flex; gap: 10px;",
                                                span { style: "color: #888; font-family: monospace;", "{idx + 1}." }
                                                span { style: "white-space: nowrap; overflow: hidden; text-overflow: ellipsis;", "{song.title.as_deref().unwrap_or(&song.path)}" }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            div { 
                                    style: "color: #b3b3b3; font-size: 0.9rem; margin-top: 4px;", 
                                    // On affiche le premier √©l√©ment de l'historique (le plus r√©cent)
                                    "{plugin_history().first().cloned().unwrap_or_default()}" 
                            }
                        }
                    },

                    // Partie Centrale (Player HTML5)
                    div { style: "flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;",
                        audio { 
                            controls: true, autoplay: true, style: "width: 100%; max-width: 500px; height: 40px; outline: none;",
                            src: "{make_url(&track.path, &root_path)}",
                            r#loop: play_mode() == PlayMode::Loop,
                            
                            // Logique de fin de piste
                            onended: move |_| {
                                // 1. Priorit√© √† la File d'attente
                                if !queue().is_empty() {
                                    let next_song = queue.write().remove(0);
                                    current_audio.set(Some(next_song.clone()));
                                    cmd_tx.send(Command::Play(next_song.id)).unwrap();
                                    cmd_tx.send(Command::GetArtistMetadataFromPlugin(next_song.path)).unwrap();
                                    return;
                                }
                                
                                // 2. Sinon gestion du mode lecture (Sequential, Random...)
                                // Note: On lit dans la liste filtr√©e ACTUELLE (donc dans la playlist si active)
                                let mode = play_mode();
                                let list = list_signal();
                                
                                // On filtre selon ce qui est affich√© √† l'√©cran
                                let audios: Vec<&MediaInfo> = list.iter()
                                    .filter(|i| i.media_type == MediaType::Audio)
                                    // On applique le m√™me filtre que l'affichage pour la suite logique
                                    .filter(|i| {
                                        if active_playlist_name().is_some() {
                                            loaded_ids_signal().contains(&i.id)
                                        } else { true }
                                    })
                                    .collect();

                                match mode {
                                    PlayMode::StopAtEnd => current_audio.set(None),
                                    PlayMode::Loop => {}, // G√©r√© par l'attribut loop HTML
                                    PlayMode::Sequential => {
                                        if let Some(idx) = audios.iter().position(|x| x.id == track.id) {
                                            if idx + 1 < audios.len() {
                                                let next = audios[idx + 1].clone();
                                                current_audio.set(Some(next.clone()));
                                                cmd_tx.send(Command::Play(next.id)).unwrap();
                                            } else { current_audio.set(None); }
                                        }
                                    },
                                    PlayMode::Random => {
                                        if !audios.is_empty() {
                                            let mut rng = rand::thread_rng();
                                            let random_idx = rng.gen_range(0..audios.len());
                                            let next = audios[random_idx].clone();
                                            current_audio.set(Some(next.clone()));
                                            cmd_tx.send(Command::Play(next.id)).unwrap();
                                        }
                                    }
                                }
                            },
                            
                            // Script pour update la barre de progression DB
                            script { "
                                var v = document.getElementById('main-player'); // Assure-toi que l'ID est bon ou utilise 'this'
                                // ... ton script existant ...
                            " }
                        }
                    },

                    // Partie Droite (Contr√¥les)
                    div { style: "width: 25%; display: flex; justify-content: flex-end; align-items: center; gap: 10px;",
                        if !queue().is_empty() {
                            button {
                                style: "background: transparent; border: 1px solid #e74c3c; color: #e74c3c; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem;",
                                onclick: move |_| queue.write().clear(),
                                "üóëÔ∏è"
                            }
                        }
                        button {
                            style: "background: transparent; border: 1px solid {play_mode().color()}; color: {play_mode().color()}; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.2s;",
                            onclick: move |_| play_mode.set(play_mode().next()),
                            "{play_mode().icon()}"
                        }
                        button {
                            style: "background: transparent; border: none; color: #fff; font-size: 1.5rem; cursor: pointer; margin-left: 10px;",
                            onclick: move |_| current_audio.set(None),
                            "‚ùå"
                        }
                    }
                }
            }
        }
    }
}

// --- FILMS (VIDEOS) ---
#[component]
pub fn Videos() -> Element {
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let mut list_signal = use_context::<Signal<Vec<MediaInfo>>>();
    let root_path_signal = use_context::<Signal<String>>();
    let root_path = root_path_signal();
    
    let plugin_history = use_context::<Signal<Vec<String>>>();
    
    let mut playing_video = use_signal(|| Option::<String>::None);
    let mut selected_media = use_signal(|| Option::<MediaInfo>::None);
    let mut search_text = use_signal(|| String::new());

    // --- LOGIQUE D'AFFICHAGE INTELLIGENT (UI) ---
    // Est-ce que les contr√¥les (Bouton retour) doivent √™tre visibles ?
    let mut ui_visible = use_signal(|| true);
    // Un compteur pour g√©rer le timer (Debounce)
    let mut activity_id = use_signal(|| 0);
    
    // Fonction appel√©e quand la souris bouge
    let on_mouse_move = move |_| {
        // 1. On rend l'interface visible
        if !ui_visible() { ui_visible.set(true); }
        
        // 2. On incr√©mente l'ID pour annuler les pr√©c√©dents timers
        let new_id = activity_id() + 1;
        activity_id.set(new_id);

        // 3. On lance un compte √† rebours de 3 secondes
        spawn(async move {
            // On attend 3 secondes (3000ms)
            // Note: On utilise le sleep de tokio (si dispo) ou std::thread::sleep est d√©conseill√© en async
            // Ici on utilise une petite astuce compatible Dioxus Desktop :
            tokio::time::sleep(std::time::Duration::from_millis(3000)).await;

            // Si l'ID n'a pas chang√© (donc pas de nouveau mouvement entre temps)
            if activity_id() == new_id {
                ui_visible.set(false);
            }
        });
    };

    // On lance le timer une fois au d√©but pour qu'il disparaisse apr√®s 3s si on ne touche √† rien
    use_hook(move || {
        let new_id = activity_id() + 1;
        activity_id.set(new_id);
        spawn(async move {
            tokio::time::sleep(std::time::Duration::from_millis(3000)).await;
            if activity_id() == new_id { ui_visible.set(false); }
        });
    });
    // --------------------------------------------
    
    let tx_init = cmd_tx.clone();
    use_hook(move || { 
        if list_signal().is_empty() { 
            tx_init.send(Command::GetAllMedia()).unwrap(); 
        } 
    });

    let css_style = "
        /* --- MODAL STYLE --- */
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; animation: fadeIn 0.3s forwards;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: #181818; width: 80%; max-width: 900px;
            border-radius: 10px; overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            display: flex; flex-direction: column;
            transform: scale(0.9); animation: popIn 0.3s forwards;
            border: 1px solid #333;
        }
        @keyframes fadeIn { to { opacity: 1; } }
        @keyframes popIn { to { transform: scale(1); } }
        
        .modal-header { height: 300px; background-size: cover; background-position: center; position: relative; }
        .modal-gradient { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to top, #181818, transparent); }
        .modal-body { padding: 40px; color: white; margin-top: -50px; position: relative; z-index: 10; }
        
        .btn-play {
            background: white; color: black; padding: 12px 30px; 
            font-size: 1.2rem; font-weight: bold; border-radius: 4px;
            border: none; cursor: pointer; display: flex; align-items: center; gap: 10px;
            transition: transform 0.2s;
        }
        .btn-play:hover { transform: scale(1.05); background: #ddd; }

        .close-btn {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.5); color: white; border-radius: 50%;
            width: 40px; height: 40px; border: 2px solid white;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; z-index: 3000; font-size: 20px;
        }
        .close-btn:hover { background: white; color: black; }

        .card-text {
            width: 100%; padding: 0 10px 10px 10px;
            font-size: 0.9rem; text-align: center; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis; box-sizing: border-box;
        }

        .page-title-centered {
            position: absolute; left: 50%; transform: translateX(-50%);
            font-size: 1.5rem; font-weight: bold; text-transform: uppercase;
            letter-spacing: 2px; pointer-events: none;
        }

        /* --- UI JOUEUR --- */
        .player-ui {
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100px;
            z-index: 10000;
            display: flex; align-items: center; padding-left: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            transition: opacity 0.5s ease-in-out;
            pointer-events: none; /* Laisse passer les clics si invisible */
        }
        
        /* Quand l'UI est active, on active les clics */
        .player-ui.visible { opacity: 1; pointer-events: auto; }
        .player-ui.hidden { opacity: 0; }
    ";

    rsx! {
        style { "{css_style}" }

        div { class: "container",
            
            // 1. LE LECTEUR VID√âO (Plein √©cran)
            if let Some(path) = playing_video() {
                div { 
                    // CORRECTION BARRE TACHES : box-sizing et hauteur fixe
                    style: "position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: black; z-index: 9999; display: flex; flex-direction: column; overflow: hidden; box-sizing: border-box;",
                    
                    // On d√©tecte le mouvement sur TOUT l'√©cran
                    onmousemove: on_mouse_move,

                    // --- ZONE BOUTON RETOUR (Dynamique) ---
                    div { 
                        class: if ui_visible() { "player-ui visible" } else { "player-ui hidden" },
                        button { class: "btn-nav", onclick: move |_| playing_video.set(None), "‚¨Ö Retour" }
                    },

                    div { 
                        // CORRECTION BARRE TACHES : Petit padding-bottom pour remonter les contr√¥les
                        style: "flex: 1; display: flex; align-items: center; justify-content: center; background: black; width: 100%; height: 100%; padding-bottom: 5px;",
                        {
                            let url = make_url(&path, &root_path);
                            rsx! {
                                video { src: "{url}", controls: true, autoplay: true, style: "width: 100%; height: 100%; object-fit: contain;" }
                            }
                        }
                    }
                }
            } 
            // 2. LA GRILLE
            else {
                div { class: "top-bar", 
                    style: "display: flex; align-items: center; justify-content: space-between; height: 60px; padding: 0 20px; position: relative;",
                    
                    div { style: "z-index: 2;", Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" } }
                    div { class: "page-title-centered", "Vid√©os" }
                    div { style: "z-index: 2;",
                        input {
                            r#type: "text", placeholder: "üîç Rechercher...",
                            style: "padding: 8px; border-radius: 5px; border: none; background: #333; color: white; width: 250px;",
                            oninput: move |evt| search_text.set(evt.value()),
                        }
                    }
                }
                
                div { class: "media-grid",
                    for item in list_signal().iter().filter(|i| i.media_type == MediaType::Video)
                        .filter(|i| { let q = search_text().to_lowercase(); if q.is_empty() { return true; } i.title.as_deref().unwrap_or(&i.path).to_lowercase().contains(&q) }) 
                    {
                        div { 
                            class: "media-card",
                            title: "{item.title.as_deref().unwrap_or(&item.path)}",
                            onclick: { 
                                let selected = item.clone();
                                let tx = cmd_tx.clone();
                                let raw_title = item.title.as_deref().unwrap_or(&item.path);
                                let clean_title = std::path::Path::new(raw_title).file_stem().and_then(|s| s.to_str()).unwrap_or(raw_title).to_string();
                                let mut history = plugin_history.clone();
                                move |_| { 
                                    history.write().insert(0, "Chargement des infos...".to_string());
                                    selected_media.set(Some(selected.clone()));
                                    tx.send(Command::GetfilmMetadataFromPlugin(clean_title.clone())).unwrap();
                                } 
                            },
                            div { class: "card-icon", "üé¨" }
                            div { class: "card-text", "{item.title.as_deref().unwrap_or(&item.path)}" }
                        }
                    }
                }
            }

            // 3. LE POPUP NETFLIX
            if let Some(media) = selected_media() {
                div { 
                    class: "modal-backdrop",
                    onclick: move |_| selected_media.set(None),
                    div { 
                        class: "modal-content",
                        onclick: move |evt| evt.stop_propagation(), 
                        div { 
                            class: "modal-header",
                            style: "background-image: linear-gradient(to bottom, #444, #181818);", 
                            div { class: "close-btn", onclick: move |_| selected_media.set(None), "‚úï" }
                            div { class: "modal-gradient" }
                        }
                        div { class: "modal-body",
                            h1 { style: "font-size: 3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px black;", 
                                "{media.title.as_deref().unwrap_or(&media.path)}" 
                            }
                            div { style: "display: flex; gap: 15px; margin-bottom: 20px;",
                                button { 
                                    class: "btn-play",
                                    onclick: move |_| {
                                        let id = media.id;
                                        playing_video.set(Some(media.path.clone()));
                                        selected_media.set(None);
                                        cmd_tx.send(Command::Play(id)).unwrap();
                                    },
                                    "‚ñ∂ Lecture"
                                }
                            }
                            div { 
                                style: "background: #222; padding: 20px; border-radius: 8px; min-height: 100px;",
                                if let Some(info) = plugin_history().first() {
                                    pre { style: "white-space: pre-wrap; font-family: 'Segoe UI', sans-serif; color: #ccc; line-height: 1.6;", "{info}" }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// --- IMAGES ---
#[component]
pub fn Images() -> Element {
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let list_signal = use_context::<Signal<Vec<MediaInfo>>>();
    let mut current_image = use_signal(|| Option::<String>::None);
    
    let mut search_text = use_signal(|| String::new());

    let tx_init = cmd_tx.clone();
    use_hook(move || { if list_signal().is_empty() { tx_init.send(Command::GetAllMedia()).unwrap(); } });

    rsx! {
        div { class: "container",
            if let Some(data) = current_image() {
                div { style: "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 999; display: flex; flex-direction: column;",
                    div { style: "height: 60px; padding: 10px;",
                        button { class: "btn-nav", style: "position: relative; top: 0; left: 0; transform: none;", onclick: move |_| current_image.set(None), "Fermer" }
                    }
                    div { style: "flex: 1; min-height: 0; display: flex; align-items: center; justify-content: center;",
                         img { src: "{data}", style: "max-width: 100%; max-height: 100%; object-fit: contain;" }
                    }
                }
            } 
            else {
                div { class: "top-bar", 
                    style: "display: flex; align-items: center; justify-content: space-between; position: relative; height: 60px; padding: 0 20px;",

                    div { style: "z-index: 2;",
                        Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }
                    }

                    div { 
                        class: "page-title", 
                        style: "position: absolute; left: 50%; transform: translateX(-50%); width: auto; white-space: nowrap;",
                        "Images" 
                    } 

                    div { style: "z-index: 2;",
                        input {
                            r#type: "text",
                            placeholder: "üîç Rechercher...",
                            style: "padding: 8px; border-radius: 5px; border: none; background: #333; color: white; width: 250px;",
                            oninput: move |evt| search_text.set(evt.value()),
                        }
                    }
                }

                div { class: "media-grid",
                    for item in list_signal().iter()
                        .filter(|i| i.media_type == MediaType::Image)
                        .filter(|i| {
                            let query = search_text().to_lowercase();
                            if query.is_empty() { return true; }
                            let name = i.title.as_deref().unwrap_or(&i.path).to_lowercase();
                            name.contains(&query)
                        })
                    {
                        div { class: "media-card",
                            onclick: {
                                let p=item.path.clone(); let i=item.id; let tx=cmd_tx.clone();
                                move |_| { 
                                    if let Ok(bytes) = fs::read(&p) {
                                        let b64 = general_purpose::STANDARD.encode(&bytes);
                                        current_image.set(Some(format!("data:image/png;base64,{}", b64)));
                                    }
                                    tx.send(Command::Play(i)).unwrap();
                                }
                            },
                            div { class: "card-icon", "üñºÔ∏è" }
                            div { class: "card-text", style: "overflow: hidden; text-overflow: ellipsis; white-space: nowrap; width: 100%;", "{item.title.as_deref().unwrap_or(&item.path)}" }
                        }
                    }
                }
            }
        }
    }
}

// --- PLUGINS (ADDONS) ---
#[component] 
pub fn Plugins() -> Element { 
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let plugin_history = use_context::<Signal<Vec<String>>>();
    
    // On garde le texte de recherche
    let mut search_text = use_signal(|| String::from("Inception")); 
    
    // üëá NOUVEAU : On g√®re le mode de recherche (Music ou Film)
    let mut search_mode = use_signal(|| "music"); // "music" ou "film"

    rsx! { 
        div { class: "container", 
            div { class: "top-bar", 
                Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, 
                div { class: "page-title", "PLUGINS" } 
            }
            
            div { style: "display: flex; flex-direction: column; align-items: center; gap: 30px; margin-top: 50px; padding-bottom: 50px;",
                
                // --- S√âLECTEUR DE TYPE ---
                div { style: "display: flex; gap: 20px; background: #1e1e1e; padding: 5px; border-radius: 8px; border: 1px solid #333;",
                    button {
                        style: if search_mode() == "music" { 
                            "background: #007acc; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;" 
                        } else { 
                            "background: transparent; color: #aaa; padding: 10px 20px; border: none; cursor: pointer;" 
                        },
                        onclick: move |_| { search_mode.set("music"); search_text.set("Nirvana".to_string()); },
                        "üéµ Musique (MusicBrainz)"
                    }
                    button {
                        style: if search_mode() == "film" { 
                            "background: #e50914; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;" 
                        } else { 
                            "background: transparent; color: #aaa; padding: 10px 20px; border: none; cursor: pointer;" 
                        },
                        onclick: move |_| { search_mode.set("film"); search_text.set("Inception".to_string()); },
                        "üé¨ Films (TMDB)"
                    }
                }

                // --- BARRE DE RECHERCHE ---
                div { style: "display: flex; gap: 10px;",
                    input {
                        style: "padding: 10px; border-radius: 4px; border: 1px solid #333; background: #1e1e1e; color: white; width: 300px;",
                        value: "{search_text}",
                        placeholder: if search_mode() == "music" { "Nom de l'artiste..." } else { "Titre du film..." },
                        oninput: move |evt| search_text.set(evt.value())
                    }
                    button { 
                        class: "btn-nav", 
                        style: "position: relative; transform: none; top: auto; left: auto; background: #27ae60;",
                        onclick: move |_| {
                            if !search_text().is_empty() {
                                // üëá LOGIQUE DE CHOIX DU PLUGIN
                                if search_mode() == "music" {
                                    cmd_tx.send(Command::GetArtistMetadataFromPlugin(search_text())).unwrap();
                                } else {
                                    cmd_tx.send(Command::GetfilmMetadataFromPlugin(search_text())).unwrap();
                                }
                            }
                        },
                        "üîç Rechercher"
                    }
                }

                // --- R√âSULTATS ---
                div { style: "width: 80%; max-width: 800px; display: flex; flex-direction: column; gap: 20px;",
                    if plugin_history().is_empty() {
                        div { style: "text-align: center; color: #666; font-style: italic; margin-top: 20px;", 
                            "Aucune recherche pour le moment..." 
                        }
                    }

                    for res in plugin_history().iter() {
                        div { 
                            // Petit changement de style selon le contenu (simple detection)
                            style: if res.contains("Year:") { 
                                "background: #1e1e1e; padding: 20px; border-radius: 8px; border: 1px solid #333; border-left: 5px solid #e50914;" // Rouge pour Films
                            } else {
                                "background: #1e1e1e; padding: 20px; border-radius: 8px; border: 1px solid #333; border-left: 5px solid #007acc;" // Bleu pour Musique
                            },
                            h3 { style: "margin-top: 0; color: #aaa; font-size: 0.9rem; text-transform: uppercase;", "R√©sultat :" }
                            pre { 
                                style: "color: #eee; white-space: pre-wrap; font-family: 'Segoe UI', sans-serif; font-size: 1rem; margin: 0;",
                                "{res}"
                            }
                        }
                    }
                }
            }
        } 
    } 
}

// --- AUTRES PAGES ---
#[component] pub fn Iptv() -> Element { rsx! { div { class: "container", div { class: "top-bar", Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, div { class: "page-title", "S√©ries" } } } } }
#[component] pub fn Series() -> Element { rsx! { div { class: "container", div { class: "top-bar", Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, div { class: "page-title", "S√©ries" } } } } }
#[component] pub fn PageNotFound(route: Vec<String>) -> Element { rsx! { div { class: "container", h1 { "404 - Page non trouv√©e" }, Link { to: Route::Home {}, class: "btn-nav", "Retour Accueil" } } } }

// --- PARAM√àTRES ---
#[component] 
pub fn Settings() -> Element { 
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    
    let mut scan_message = use_signal(|| String::new());

    let mut sources_signal = use_signal(|| {
        let config = LibraryConfig::load(SOURCE_FILE);
        let mut paths = Vec::new();
        for s in config.video_sources { paths.push(s.path.to_string_lossy().to_string()); }
        for s in config.music_sources { paths.push(s.path.to_string_lossy().to_string()); }
        for s in config.image_sources { paths.push(s.path.to_string_lossy().to_string()); }
        paths.sort();
        paths.dedup();
        paths
    });

    rsx! { 
        div { class: "container", 
            div { class: "top-bar", 
                Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, 
                div { class: "page-title", "Param√®tres" } 
            }
  
            div { style: "display: flex; flex-direction: column; align-items: center; gap: 30px; margin-top: 50px; max-width: 800px; margin-left: auto; margin-right: auto; padding-bottom: 50px;",
                
                div { style: "text-align: center; width: 100%;",
                    h2 { "Gestion des Sources" }
                    p { style: "color: #aaa; margin-bottom: 20px;", "G√©rez ici les dossiers que NeoKodi doit scanner." }
                }

                div { style: "width: 100%; display: flex; flex-direction: column; gap: 10px;",
                    if sources_signal().is_empty() {
                        div { style: "text-align: center; font-style: italic; color: #666; padding: 20px;", "Aucune source configur√©e." }
                    }

                    for path in sources_signal().iter() {
                        div { 
                            style: "background: #1e1e1e; padding: 15px; border-radius: 8px; border: 1px solid #333; display: flex; justify-content: space-between; align-items: center;",
                            
                            div { style: "font-family: monospace; color: #007acc; font-size: 1.1rem;", "üìÇ {path}" }
                            
                            button {
                                class: "btn-nav",
                                style: "position: relative; transform: none; top: auto; left: auto; background: #c0392b; padding: 8px 15px; font-size: 0.9rem;",
                                onclick: {
                                    let p = path.clone();
                                    let tx = cmd_tx.clone();
                                    move |_| {
                                        let path_buf = PathBuf::from(&p);
                                        tx.send(Command::RemoveSource(path_buf.clone(), MediaType::Video)).unwrap();
                                        tx.send(Command::RemoveSource(path_buf.clone(), MediaType::Audio)).unwrap();
                                        tx.send(Command::RemoveSource(path_buf.clone(), MediaType::Image)).unwrap();
                                        
                                        sources_signal.write().retain(|x| x != &p);
                                    }
                                },
                                "üóëÔ∏è"
                            }
                        }
                    }
                }

                button { 
                    class: "btn-nav", 
                    style: "position: relative; transform: none; top: auto; left: auto; font-size: 1.1rem; padding: 15px 30px; background-color: #27ae60;",
                    onclick: {
                        let tx = cmd_tx.clone(); 
                            move |_| {
                            if let Some(path) = rfd::FileDialog::new().pick_folder() {
                                let path_str = path.to_string_lossy().to_string();
                                if !sources_signal().contains(&path_str) {
                                    tx.send(Command::AddSource(path.clone(), MediaType::Video)).unwrap();
                                    tx.send(Command::AddSource(path.clone(), MediaType::Audio)).unwrap();
                                    tx.send(Command::AddSource(path.clone(), MediaType::Image)).unwrap();
                                    tx.send(Command::Reload()).unwrap(); 
                                    sources_signal.write().push(path_str);
                                }
                            }
                        }
                    },
                    "‚ûï Ajouter un dossier"
                }

                div { style: "width: 100%; height: 1px; background: #333; margin: 20px 0;" }

                div { style: "text-align: center; width: 100%;",
                    h2 { "Maintenance" }
                    p { style: "color: #aaa; margin-bottom: 20px;", "Si vos fichiers n'apparaissent pas, forcez une relecture compl√®te." }
                    div { style: "display: flex; flex-direction: column; align-items: center; gap: 10px;",
                        button {
                            class: "btn-nav",
                            style: "position: relative; transform: none; top: auto; left: auto; font-size: 1.1rem; padding: 15px 30px; background-color: #2980b9;",
                            onclick: {
                                let tx = cmd_tx.clone();
                                move |_| {
                                    scan_message.set("‚è≥ Analyse des fichiers en cours...".to_string());
                                    tx.send(Command::Reload()).unwrap();
                                    spawn(async move {
                                        tokio::time::sleep(Duration::from_secs(3)).await;
                                        scan_message.set(String::new());
                                    });
                                }
                            },
                            "üîÑ Forcer le re-scan complet"
                        }
                        // Message de confirmation
                        if !scan_message().is_empty() {
                            div { style: "color: #2ecc71; font-weight: bold; margin-top: 10px;", "{scan_message}" }
                        }
                    }
                }
            }
        } 
    } 
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/gui/route.rs
// ---------------------------------------------------------
use dioxus::prelude::*;
use super::pages::*;

#[derive(Routable, Clone)]
#[rustfmt::skip]
pub enum Route {
    #[route("/")]
    Home {},

    #[route("/Videos")]
    Videos {},

    #[route("/images")]
    Images {},

    #[route("/music")]
    Music {},

    #[route("/series")]
    Series {},

    #[route("/iptv")]
    Iptv {},

    // üëá VOIL√Ä CELUI QUI MANQUAIT
    #[route("/Plugins")]
    Plugins {},

    #[route("/settings")]
    Settings {},

    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/gui/style.rs
// ---------------------------------------------------------
pub const GLOBAL_STYLE: &str = r#"
    /* RESET GLOBAL */
    html, body { 
        margin: 0; 
        padding: 0;
        font-family: 'Segoe UI', sans-serif; 
        background-color: #121212; 
        color: white; 
        
        /* üëá ON BLOQUE LE CORPS DE PAGE */
        width: 100vw;
        height: 100vh;
        overflow: hidden; /* C'est le container qui scrollera, pas le body */
    }
    
    * { box-sizing: border-box; }
    a { text-decoration: none; color: inherit; }

    /* CONTENEUR PRINCIPAL */
    .container { 
        display: flex; 
        flex-direction: column;
        
        /* üëá LA CORRECTION EST ICI : 100vh FORCE LA TAILLE DE L'√âCRAN */
        height: 100vh;
        width: 100%;
        
        /* C'est ici qu'on active le scroll */
        overflow-y: auto;
        overflow-x: hidden;
        
        padding: 0; 
    }

    /* --- SCROLLBAR PERSONNALIS√âE (Pour √™tre s√ªr qu'on la voit) --- */
    /* WebKit (Chrome, Edge, WebView2) */
    ::-webkit-scrollbar {
        width: 14px; /* Un peu plus large pour √™tre visible */
    }
    ::-webkit-scrollbar-track {
        background: #0a0a0a; 
        border-left: 1px solid #333;
    }
    ::-webkit-scrollbar-thumb {
        background: #444; 
        border-radius: 7px;
        border: 2px solid #0a0a0a; /* Petit bord pour faire joli */
    }
    ::-webkit-scrollbar-thumb:hover {
        background: #007acc; /* Devient bleu au survol */
    }

    /* --- BARRE DU HAUT (STICKY) --- */
    .top-bar {
        position: sticky; 
        top: 0;
        z-index: 100;
        background-color: #121212; /* Opaque pour cacher le contenu qui passe dessous */
        
        display: flex;
        justify-content: center;
        align-items: center;
        
        padding: 20px;
        margin-bottom: 20px;
        border-bottom: 1px solid #333;
        min-height: 80px;
        flex-shrink: 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.8);
    }

    .page-title {
        font-size: 2rem;
        font-weight: bold;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .btn-nav {
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background-color: #252525;
        color: #aaa;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: bold;
        transition: 0.2s;
        border: 1px solid #333;
        cursor: pointer;
        display: flex; align-items: center; gap: 10px;
        z-index: 10;
    }
    .btn-nav:hover {
        background-color: #007acc;
        color: white;
        border-color: #007acc;
    }

    /* --- CONTENU --- */
    .media-grid, .audio-list {
        padding: 20px; 
        padding-bottom: 100px; /* Grosse marge en bas pour scroller confortablement */
    }

    /* --- GRILLE --- */
    .media-grid { 
        display: grid; 
        /* Responsive intelligent */
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); 
        gap: 25px; 
    }

    .media-card { 
        background: #1e1e1e; 
        border-radius: 12px; 
        padding: 20px;
        display: flex; 
        flex-direction: column;
        align-items: center; 
        justify-content: center; 
        transition: transform 0.2s, background-color 0.2s;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        border: 1px solid #333;
        cursor: pointer;
        min-height: 180px; 
        text-align: center;
    }

    .media-card:hover {
        transform: translateY(-5px);
        background-color: #2d2d2d;
        border-color: #007acc;
    }

    .card-icon { font-size: 3rem; margin-bottom: 15px; }
    .card-text { font-size: 1.1rem; font-weight: 600; }

    /* --- LISTE AUDIO --- */
    .audio-list { display: flex; flex-direction: column; gap: 10px; }
    
    .audio-row {
        display: flex; align-items: center;
        background-color: #1e1e1e; padding: 12px 20px;
        border-radius: 8px; cursor: pointer;
        border: 1px solid transparent; transition: 0.2s;
    }
    .audio-row:hover { background-color: #2d2d2d; border-color: #444; transform: translateX(5px); }
    
    .audio-icon { 
        width: 45px; height: 45px; 
        background: #333; border-radius: 6px; 
        margin-right: 20px; display: flex; align-items: center; justify-content: center; 
        font-size: 1.5rem; 
    }
    .audio-info { flex: 1; }
    .audio-title { font-weight: 600; }
    .audio-artist { font-size: 0.85rem; color: #888; }
    
    .loading-container {
        width: 100%;
        max-width: 500px;
        background-color: #333;
        border-radius: 4px;
        height: 6px;
        overflow: hidden;
        margin-top: 20px;
        position: relative;
    }

    .loading-bar {
        height: 100%;
        background-color: #007acc;
        width: 50%;
        position: absolute;
        animation: loading 1.5s infinite ease-in-out;
        border-radius: 4px;
    }

    @keyframes loading {
        0% { left: -50%; width: 30%; }
        50% { width: 60%; }
        100% { left: 100%; width: 30%; }
    }
"#;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/iptv/mod.rs
// ---------------------------------------------------------
pub mod parser;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/iptv/parser.rs
// ---------------------------------------------------------
// src/iptv/parser.rs

#[derive(Debug, Clone, PartialEq)]
pub enum ContentType {
    Live,
    Movie,
    Series,
}

#[derive(Debug, Clone)]
pub struct TVChannel {
    pub title: String,
    pub url: String,
    pub group: Option<String>,
    pub content_type: ContentType,
}

pub fn parse_m3u(content: &str) -> Vec<TVChannel> {
    let mut channels = Vec::new();
    let mut current_title = String::new();
    let mut current_group = None;

    for line in content.lines() {
        let line = line.trim();

        if line.starts_with("#EXTINF:") {
            // 1. Extraction du Titre
            if let Some(comma_index) = line.rfind(',') {
                current_title = line[comma_index + 1..].trim().to_string();
            }

            // 2. Extraction du Groupe
            if let Some(start) = line.find("group-title=\"") {
                let rest = &line[start + 13..];
                if let Some(end) = rest.find('"') {
                    let group_name = rest[..end].to_string();
                    current_group = Some(group_name);
                }
            }
        } else if !line.starts_with("#") && !line.is_empty() {
            // 3. D√©tection
            let content_type = detect_type(&current_group);

            // LOG DE DEBUG : D√©commenter si tu veux voir ce qui se passe
            // if content_type != ContentType::Live {
            //     println!("üîé Trouv√© {:?} dans le groupe '{:?}' -> {}", content_type, current_group, current_title);
            // }

            channels.push(TVChannel {
                title: current_title.clone(),
                url: line.to_string(),
                group: current_group.clone(),
                content_type,
            });
            
            current_title.clear();
            current_group = None;
        }
    }
    
    channels
}

fn detect_type(group: &Option<String>) -> ContentType {
    match group {
        Some(g) => {
            let g_upper = g.to_uppercase();
            
            // Mots-cl√©s pour S√âRIES (tr√®s large)
            if g_upper.contains("SERIE") || 
               g_upper.contains("S√âRIE") || 
               g_upper.contains("SEASON") || 
               g_upper.contains("SAISON") ||
               g_upper.contains("EPISODE") {
                return ContentType::Series;
            }

            // Mots-cl√©s pour FILMS (tr√®s large)
            if g_upper.contains("MOVIE") || 
               g_upper.contains("FILM") || 
               g_upper.contains("VOD") || 
               g_upper.contains("CINEMA") || 
               g_upper.contains("4K") || // Souvent les films sont tagu√©s 4K
               g_upper.contains("FHD") || 
               g_upper.contains("HEVC") {
                // Attention : Parfois les cha√Ænes live ont aussi FHD, 
                // mais dans les M3U IPTV, VOD est souvent explicite.
                // Si ton M3U m√©lange tout, c'est plus dur.
                
                // Raffinement : Si √ßa contient "VOD", c'est s√ªr que c'est un film/s√©rie
                if g_upper.contains("VOD") {
                     return ContentType::Movie;
                }
                
                // Sinon on tente le coup sur "FILM"
                if g_upper.contains("FILM") || g_upper.contains("MOVIE") {
                    return ContentType::Movie;
                }
            }

            ContentType::Live
        },
        None => ContentType::Live,
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/library/media_library.rs
// ---------------------------------------------------------
use crate::database::db::DB;


use crate::media;
use crate::media::data::Media;
use crate::media::data::MediaType;
use crate::media::audio::Audio;
use crate::media::image::Image;
use crate::media::video::Video;
use crate::media::data::MediaInfo;


use std::fs;
use std::collections::HashMap;
use std::path::Path;


use crate::constants::LOG_FILE;
use crate::scan::scan::Scan;
use std::path::PathBuf;
use std::fs::File;
use lazy_static::lazy_static;
use std::sync::RwLock;

use crate::logger::logger::Logger;

lazy_static! {
    // Une liste de MediaInfo, prot√©g√©e par un verrou (RwLock) pour que les threads ne se marchent pas dessus.
    pub static ref MEDIA_LIBRARY: RwLock<Vec<MediaInfo>> = RwLock::new(Vec::new());
}

#[derive(Debug, Clone)]
pub struct ScannedMedia {
    pub path: String,
    pub name: String,
    pub duration: f32,
    pub media_type: MediaType,
}
pub struct MediaLibrary {
    pub items: HashMap<i64, Box<dyn Media>>,
    pub scan_lib: Scan,
    pub database: DB,
}

impl MediaLibrary {
    pub fn new() -> Self {

        Self {
            items: HashMap::new(),
            scan_lib: Scan::new(),
            database: DB::new(),
        }
    }

    pub fn init(&mut self) {



        // scan the libraries
        self.database.init_db().unwrap();
        self.scan_lib.scan_libraries();

        // update the database
        self.database.upsert_media_from_scan(self.scan_lib.scan.clone()).unwrap(); //TODO: ce clone me fait chier, il faudrait qu'on utilise juste scan (ca serait meme mieux si on donne la valeur direct comme ca il se fait drop (on en a plus besoin ) et mm en terme de performance c'est pas terrible parce que c'est un gros object )
        self.database.cleanup_missing_media(self.scan_lib.scan.clone()).unwrap(); // TODO to implement, shuld be called every scans
        self.database.get_all_media().unwrap();
        //self.database.print_media_rows();


    
        
        for row in self.database.media_rows.iter() {
            let media: Box<dyn Media> = match row.media_type {
                
                MediaType::Audio => Box::new(Audio::new(
                    row.id, 
                    &row.path, 
                    &row.title.as_deref().unwrap_or(""),
                    row.last_position
                )),
                
                MediaType::Video => Box::new(Video::new(row.id, &row.path, &row.title.as_deref().unwrap_or(""), row.last_position, row.duration.unwrap_or(0.0))),
                MediaType::Image => Box::new(Image::new(row.id, &row.path, &row.title.as_deref().unwrap_or(""))), 
            };
            self.items.insert(row.id, media);
        }

    }    

    pub fn reload(&mut self) {
        let logger = Logger::new(LOG_FILE);
        self.init();
    }

    pub fn update_media_status_and_time(&mut self, media_id: i64, status: i32, time_stop: f64, duration: f32) {
        let logger = Logger::new(LOG_FILE);
        // On appelle la nouvelle fonction DB (qu'on va cr√©er juste apr√®s)
        match self.database.update_media_status_and_time(media_id, status, time_stop, duration) {
            Ok(_) => {}, // logger.debug(...),
            Err(e) => logger.error(&format!("Error updating progress ID {}: {}", media_id, e)),
        }
    }

    pub fn create_playlist(&mut self, name: &str) {

        let logger = Logger::new(LOG_FILE);

        match self.database.create_playlist(name) {
            Ok(playlist_id) => logger.debug(&format!("Created playlist '{}' with ID {}", name, playlist_id)),
            Err(e) => logger.error(&format!("Playlist '{}' already exists: {}", name, e)),
        }
    }

    pub fn delete_playlist(&mut self, playlist_id: i64) {

        let logger = Logger::new(LOG_FILE);
        match self.database.delete_playlist(playlist_id) {
            Ok(_) => logger.debug(&format!("Deleted playlist with ID {}", playlist_id)),
            Err(e) => logger.error(&format!("Error deleting playlist ID {}: {}", playlist_id, e)),
        }
    }

    pub fn add_media_to_playlist(&mut self, media_id: i64, playlist_id: i64) {
        println!("üìö [LIB] Appel DB pour ajout {} -> {}", media_id, playlist_id); // DEBUG

        let logger = Logger::new(LOG_FILE);

        match self.database.add_media_to_playlist(media_id, playlist_id) {
            Ok(_) => logger.debug(&format!("Media ID {} added to Playlist ID {}", media_id, playlist_id)),
            Err(e) => logger.error(&format!("Error adding Media ID {} to Playlist ID {}: {}", media_id, playlist_id, e)),
        }
    }
    
    pub fn remove_media_from_playlist(&mut self, media_id: i64, playlist_id: i64) {

        let logger = Logger::new(LOG_FILE);

        match self.database.remove_media_from_playlist(media_id, playlist_id) {
            Ok(_) => logger.debug(&format!("Media ID {} removed from Playlist ID {}", media_id, playlist_id)),
            Err(e) => logger.error(&format!("Error removing Media ID {} from Playlist ID {}: {}", media_id, playlist_id, e)),
        }
    }

    pub fn get_media_from_playlist(&mut self, playlist_id: i64) -> Vec<i64> {

        let logger = Logger::new(LOG_FILE);

        match self.database.get_media_from_playlist(playlist_id) {
            Ok(media_list) => media_list,
            Err(e) => {
                logger.error(&format!("Error retrieving media from Playlist ID {}: {}", playlist_id, e));
                Vec::new()
            }
        }
    }

    pub fn get_playlist_id(&mut self, name: &str) -> i64 {
        
        let logger = Logger::new(LOG_FILE);

        match self.database.get_playlist_id(name) {
            Ok(playlist_id) => playlist_id,
            Err(e) => {
                logger.error(&format!("Error retrieving playlist ID for '{}': {}", name, e));
                -1
            }
        }
    }

    pub fn get_all_playlists(&mut self) -> Vec<(i64, String)> {

        let logger = Logger::new(LOG_FILE);
        
        match self.database.get_all_playlists() {
            Ok(playlists) => playlists,
            Err(e) => {
                logger.error(&format!("Error retrieving playlists: {}", e));
                Vec::new()
            }
        }
    }

    pub fn add_tag(&mut self, tag_name: &str) {

        let logger = Logger::new(LOG_FILE);

        match self.database.get_or_create_tag(tag_name) {
            Ok(tag_id) => logger.debug(&format!("Tag '{}' has ID {}", tag_name, tag_id)),
            Err(e) => logger.error(&format!("Error adding tag '{}': {}", tag_name, e)),
        }
    }

    pub fn get_all_tags(&mut self) -> Vec<(i64, String)> {

        let logger = Logger::new(LOG_FILE);

        match self.database.get_all_tags() {
            Ok(tags) => tags,
            Err(e) => {
                logger.error(&format!("Error retrieving tags: {}", e));
                Vec::new()
            }
        }
    }

    pub fn remove_tag(&mut self, tag_id: i64) {

        let logger = Logger::new(LOG_FILE);

        match self.database.remove_tag(tag_id) {
            Ok(_) => logger.debug(&format!("Removed tag with ID {}", tag_id)),
            Err(e) => logger.error(&format!("Error removing tag ID {}: {}", tag_id, e)),
        }
    }

    pub fn remove_tag_from_media(&mut self, media_id: i64, tag_id: i64) {
        let logger = Logger::new(LOG_FILE);

        match self.database.remove_tag_from_media(media_id, tag_id) {
            Ok(_) => logger.debug(&format!("Tag ID {} removed from Media ID {}", tag_id, media_id)),
            Err(e) => logger.error(&format!("Error removing Tag ID {} from Media ID {}: {}", tag_id, media_id, e)),
        }
    }

    pub fn add_tag_to_media(&mut self, media_id: i64, tag_id: i64) {

        let logger = Logger::new(LOG_FILE);

        match self.database.add_tag_to_media(media_id, tag_id) {
            Ok(_) => logger.debug(&format!("Tag ID {} added to Media ID {}", tag_id, media_id)),
            Err(e) => logger.error(&format!("Error adding Tag ID {} to Media ID {}: {}", tag_id, media_id, e)),
        }
    }

    pub fn get_tag_id(&mut self, tag_name: &str) -> i64 {
        
        let logger = Logger::new(LOG_FILE);

        match self.database.get_tag_id(tag_name) {
            Ok(tag_id) => tag_id,
            Err(e) => {
                logger.error(&format!("Error retrieving tag ID for '{}': {}", tag_name, e));
                -1
            }
        }
    }

    pub fn add_source(&mut self, path: PathBuf, media_type: MediaType) {
        match media_type {
            MediaType::Audio => self.scan_lib.libraries.add_audio_source(path),
            MediaType::Video => self.scan_lib.libraries.add_video_source(path),
            MediaType::Image => self.scan_lib.libraries.add_image_source(path),
        }

        self.reload();
    }

    pub fn remove_source(&mut self, path: PathBuf, media_type: MediaType) {
        match media_type {
            MediaType::Audio => self.scan_lib.libraries.remove_audio_source(path),
            MediaType::Video => self.scan_lib.libraries.remove_video_source(path),
            MediaType::Image => self.scan_lib.libraries.remove_image_source(path),
        }

        self.reload();
    }

    pub fn get_media_from_path(&mut self, path: PathBuf) -> Vec<MediaInfo> {
        let mut result = Vec::new();

        for (_id, item) in self.items.iter() {
            if item.get_path().starts_with(path.to_str().unwrap()) {
                result.push(item.info());
            }
        }

        result
    }

    pub fn get_all_media(&self) -> Vec<MediaInfo> {
        let mut result = Vec::new();

        for (_id, item) in self.items.iter() {
            result.push(item.info());
        }

        result
    }

    pub fn get_media_by_type(&self, media_type: MediaType) -> Vec<MediaInfo> {
        let mut result = Vec::new();

        for (_id, item) in self.items.iter() {
            if item.media_type() == media_type {
                result.push(item.info());
            }
        }

        result
    }

    pub fn get_media_from_tag(&mut self, tag_id: &str) -> Vec<i64> {
        let media_list = self.database.get_media_by_tag(tag_id).unwrap();
        media_list
    }

   
    pub fn play_id(&mut self, id: i64) {

        let logger = Logger::new(LOG_FILE);

        if let Some(item) = self.items.get_mut(&id) {
            logger.debug(&format!("Playing media ID {id}: {}", item.get_name()));
            item.init();
            item.play();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }

    pub fn pause_id(&mut self, id: i64) {

        let logger = Logger::new(LOG_FILE);

        logger.debug(&format!("Pausing media ID {id}"));
        if let Some(item) = self.items.get_mut(&id) {
            item.pause();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }

    pub fn resume_id(&mut self, id: i64) {
        let logger = Logger::new(LOG_FILE);

        if let Some(item) = self.items.get_mut(&id) {
            item.resume();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }

    pub fn stop_id(&mut self, id: i64) {
        let logger = Logger::new(LOG_FILE);

        if let Some(item) = self.items.get_mut(&id) {
            item.stop();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }


    pub fn info_id(&self, id: i64) -> Option<MediaInfo> {
        if let Some(item) = self.items.get(&id) {
            Some(item.info())
        } else {
            None
        }
    }

    pub fn media_type_id(&self, id: i64) -> Option<crate::media::data::MediaType> {
        if let Some(item) = self.items.get(&id) {
            Some(item.media_type())
        } else {
            None
        }
    }

    pub fn clear(&mut self) {
        println!("üî• GRAND NETTOYAGE EN COURS...");

        // 1. On vide la m√©moire RAM
        self.items.clear();
        
        // 2. On vide la Base de Donn√©es
        if let Err(e) = self.database.clear_all_media() {
            println!("‚ùå Erreur lors du nettoyage de la DB : {}", e);
        } else {
            println!("‚úÖ Base de donn√©es vid√©e.");
        }

        // 3. ON R√âINITIALISE LE SCANNER PROPREMENT
        // Au lieu de supprimer le fichier (ce qui casse tout), on l'√©crase avec un JSON vide valide.
        // Cela permet au scanner de repartir sur une base saine.
        let sources_path = Path::new("db/sources.json");
        
        // On √©crit un objet JSON vide "{}" pour ne pas faire planter le parser JSON
        if let Err(e) = fs::write(sources_path, "{}") {
             println!("‚ö†Ô∏è Impossible de r√©initialiser sources.json : {}", e);
        } else {
             println!("‚úÖ Fichier sources.json r√©initialis√© (chemins oubli√©s).");
        }

        // On recharge un scanner tout neuf qui lira ce fichier vide
        self.scan_lib = Scan::new();
    }

}



#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    struct TestMedia {
        path: String,
        name: String,
        mtype: MediaType,
        played: bool,
        paused: bool,
        resumed: bool,
        stopped: bool,
    }

    impl TestMedia {
        fn new(id: i64, path: &str, name: &str, mtype: MediaType) -> (i64, Box<dyn Media>) {
            (
                id,
                Box::new(Self {
                    path: path.into(),
                    name: name.into(),
                    mtype,
                    played: false,
                    paused: false,
                    resumed: false,
                    stopped: false,
                }),
            )
        }
    }

    impl Media for TestMedia {
        fn init(&mut self) {}
        fn play(&mut self) { self.played = true; }
        fn pause(&self) { let _ = &self.paused; }
        fn resume(&self) { let _ = &self.resumed; }
        fn stop(&self) { let _ = &self.stopped; }
        fn info(&self) -> MediaInfo {
            MediaInfo {
                id: 0,
                path: self.path.clone(),
                title: Some(self.name.clone()),
                duration: None,
                media_type: MediaType::Audio,
                last_position: 0.0,
            }
        }
        fn media_type(&self) -> MediaType { MediaType::Audio }
        fn get_name(&self) -> String { self.name.clone() }
        fn get_path(&self) -> String { self.path.clone() }
    }

    fn test_library(items: Vec<(i64, Box<dyn Media>)>) -> MediaLibrary {
        MediaLibrary {
            items: HashMap::from_iter(items),
            scan_lib: Scan { libraries: crate::library::sources::LibraryConfig::load("db/sources.json"), scan: Vec::new() },
            database: DB { conn: rusqlite::Connection::open_in_memory().unwrap(), media_rows: Vec::new() },
        }
    }

    #[test]
    fn info_and_media_type_by_id() {
        let mut lib = test_library(vec![TestMedia::new(1, "/media/a.mp3", "Song", MediaType::Audio)]);
        assert_eq!(lib.info_id(1).unwrap().path, "/media/a.mp3");
        assert!(lib.info_id(99).is_none());
        assert_eq!(lib.media_type_id(1), Some(MediaType::Audio));
        assert_eq!(lib.media_type_id(99), None);
    }

    #[test]
    fn get_all_and_by_type() {
        let lib = test_library(vec![
            TestMedia::new(1, "/media/a.mp3", "Song", MediaType::Audio),
            TestMedia::new(2, "/media/v.mp4", "Clip", MediaType::Video),
        ]);
        let all = lib.get_all_media();
        assert_eq!(all.len(), 2);
        let audios = lib.get_media_by_type(MediaType::Audio);
        //println!("audios: {:?}", audios);
        assert_eq!(audios.len(), 2);
    }

    #[test]
    fn get_media_from_path_filters_prefix() {
        let mut lib = test_library(vec![
            TestMedia::new(1, "/media/music/a.mp3", "A", MediaType::Audio),
            TestMedia::new(2, "/videos/b.mp4", "B", MediaType::Video),
        ]);
        let list = lib.get_media_from_path(PathBuf::from("/media"));
        assert_eq!(list.len(), 1);
        assert_eq!(list[0].path, "/media/music/a.mp3");
    }

    #[test]
    fn play_pause_resume_stop_do_not_panic() {
        let mut lib = test_library(vec![TestMedia::new(1, "/media/a.mp3", "Song", MediaType::Audio)]);
        lib.play_id(1);
        lib.pause_id(1);
        lib.resume_id(1);
        lib.stop_id(1);
    }

    #[test]
    fn add_media_to_playlist_handles_missing() {
        let mut lib = test_library(vec![]);
        // should not panic when ID missing
        lib.play_id(42);
        lib.pause_id(42);
        lib.resume_id(42);
        lib.stop_id(42);
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/library/mod.rs
// ---------------------------------------------------------
pub mod sources;
pub mod media_library;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/library/sources.rs
// ---------------------------------------------------------

/*
This file manages media sources for the library,
loading and saving source configurations to a JSON file.
*/

use std::fs;
use serde::{Serialize, Deserialize};
use std::path::PathBuf;

use crate::constants::constants::SOURCE_FILE;

#[derive(Serialize, Deserialize, Debug)]
pub struct MediaSource {
    pub path: PathBuf,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct LibraryConfig {
    pub sources: Vec<MediaSource>,
    pub music_sources: Vec<MediaSource>,
    pub video_sources: Vec<MediaSource>,
    pub image_sources: Vec<MediaSource>,
}

impl LibraryConfig {
    pub fn load(path: &str) -> Self {
        if let Ok(data) = fs::read_to_string(path) {
           // println!("Fichier charg√© : {}", data);
            if let Ok(config) = serde_json::from_str(&data) {
                // println!("Configuration pars√©e : {:?}", config);
                return config;
            }
        }

        // Si le fichier n'existe pas ou est vide
        Self { sources: Vec::new(), music_sources: Vec::new(), video_sources: Vec::new(), image_sources: Vec::new() }
    }

    pub fn save(&self, path: &str) {
        let json = serde_json::to_string_pretty(&self).unwrap();
        fs::write(path, json).unwrap();
    }


    pub fn add_source(&mut self, folder: PathBuf) {
        if !self.sources.iter().any(|s| s.path == folder) {
            self.sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }
    pub fn add_audio_source(&mut self, folder: PathBuf) {
        if !self.music_sources.iter().any(|s| s.path == folder) {
            self.music_sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }
    pub fn add_video_source(&mut self, folder: PathBuf) {
        if !self.video_sources.iter().any(|s| s.path == folder) {
            self.video_sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }
    pub fn add_image_source(&mut self, folder: PathBuf) {
        if !self.image_sources.iter().any(|s| s.path == folder) {
            self.image_sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }

        pub fn remove_source(&mut self, folder: PathBuf) {
        self.sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }


    pub fn remove_audio_source(&mut self, folder: PathBuf) {
        self.music_sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }

    pub fn remove_video_source(&mut self, folder: PathBuf) {
        self.video_sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }

    pub fn remove_image_source(&mut self, folder: PathBuf) {
        self.image_sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }

    
}









#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::time::{SystemTime, UNIX_EPOCH};

    fn temp_file(label: &str) -> String {
        let stamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        std::env::temp_dir()
            .join(format!("epikodi_sources_{label}_{stamp}.json"))
            .to_string_lossy()
            .to_string()
    }

    #[test]
    fn load_nonexistent_file_returns_empty_config() {
        let path = temp_file("nonexistent");
        let config = LibraryConfig::load(&path);
        assert_eq!(config.sources.len(), 0);
        assert_eq!(config.music_sources.len(), 0);
        assert_eq!(config.video_sources.len(), 0);
        assert_eq!(config.image_sources.len(), 0);
    }

    #[test]
    fn save_and_load_persists_config() {
        let path = temp_file("persist");
        let mut config = LibraryConfig {
            sources: vec![MediaSource { path: PathBuf::from("/media") }],
            music_sources: vec![MediaSource { path: PathBuf::from("/music") }],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.save(&path);

        let loaded = LibraryConfig::load(&path);
        assert_eq!(loaded.sources.len(), 1);
        assert_eq!(loaded.sources[0].path, PathBuf::from("/media"));
        assert_eq!(loaded.music_sources.len(), 1);
        assert_eq!(loaded.music_sources[0].path, PathBuf::from("/music"));

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_source_prevents_duplicates() {
        let path = temp_file("no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_source(PathBuf::from("/media"));
        config.add_source(PathBuf::from("/media"));

        assert_eq!(config.sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_audio_source_prevents_duplicates() {
        let path = temp_file("audio_no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_audio_source(PathBuf::from("/music"));
        config.add_audio_source(PathBuf::from("/music"));

        assert_eq!(config.music_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_video_source_prevents_duplicates() {
        let path = temp_file("video_no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_video_source(PathBuf::from("/videos"));
        config.add_video_source(PathBuf::from("/videos"));

        assert_eq!(config.video_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_image_source_prevents_duplicates() {
        let path = temp_file("image_no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_image_source(PathBuf::from("/images"));
        config.add_image_source(PathBuf::from("/images"));

        assert_eq!(config.image_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    #[ignore]
    fn add_source_saves_to_file() {
        let path = temp_file("save_check");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_source(PathBuf::from("/media"));

        // Verify file exists after save
        assert!(fs::metadata(&path).is_ok());

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn multiple_sources_can_coexist() {
        let path = temp_file("multi");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_audio_source(PathBuf::from("/music1"));
        config.add_audio_source(PathBuf::from("/music2"));
        config.add_video_source(PathBuf::from("/videos1"));
        config.add_image_source(PathBuf::from("/images1"));

        assert_eq!(config.music_sources.len(), 2);
        assert_eq!(config.video_sources.len(), 1);
        assert_eq!(config.image_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/logger/logger.rs
// ---------------------------------------------------------
/*
logger.rs - A simple logging utility for EpiKodi
*/


/* 
    let logger = Logger::new(LOG_FILE);

    // Log some messages
    logger.info("Application started");
    logger.debug("This is a debug message");
    logger.warning("This is a warning message");
    logger.error("This is an error message");
*/

use std::fs::OpenOptions;
use std::io::Write;
use chrono::Local;

use crate::constants::constants::{DEBUG, LOG_IN_CONSOLE};

// Define the different log levels
#[derive(Debug, Clone, Copy)]
pub enum LogLevel {
    Info,
    Warning,
    Error,
    Debug,
}

impl LogLevel {
    // Convert log level to a string for display
    fn as_str(&self) -> &str {
        match self {
            LogLevel::Info => "INFO",
            LogLevel::Warning => "WARNING",
            LogLevel::Error => "ERROR",
            LogLevel::Debug => "DEBUG",
        }
    }
}

// The Logger struct
pub struct Logger {
    log_file: String,
}

impl Logger {
    // Create a new logger instance
    pub fn new(log_file: &str) -> Self {
        Logger {
            log_file: log_file.to_string(),
        }
    }

    // Main logging method
    pub fn log(&self, level: LogLevel, message: &str) {
        // Get current timestamp
        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S");
        
        // Format the log entry
        let log_entry = format!("[{}] [{}] {}\n", timestamp, level.as_str(), message);
        
        // Print to console
        if LOG_IN_CONSOLE {print!("{}", log_entry);}
        
        // Write to file
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
            .expect("Failed to open log file");
        
        file.write_all(log_entry.as_bytes())
            .expect("Failed to write to log file");
    }

    // Convenience methods for each log level
    pub fn info(&self, message: &str) {
        self.log(LogLevel::Info, message);
    }

    pub fn warning(&self, message: &str) {
        self.log(LogLevel::Warning, message);
    }

    pub fn error(&self, message: &str) {
        self.log(LogLevel::Error, message);
    }

    pub fn debug(&self, message: &str) {
        if DEBUG {
            self.log(LogLevel::Debug, message);
        }
    }
}


// ---------------------------------------------------------
// FILE: ./EpiKodi/src/logger/mod.rs
// ---------------------------------------------------------
pub mod logger;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/main.rs
// ---------------------------------------------------------
#![allow(non_snake_case)]

mod constants;
mod threading;
mod database;
mod media;
mod library;
mod scan;
mod config;
mod gui;
mod iptv;
mod logger; 
mod plugin;

use crate::logger::logger::Logger;
use crate::constants::LOG_FILE;

use crate::gui::style::GLOBAL_STYLE;
use crate::config::AppConfig;
use crate::gui::init::{App, RELOAD_SIGNAL}; 

use std::thread;
use std::time::Duration;
use std::path::Path;

use dioxus::prelude::*;
use dioxus::desktop::{Config, WindowBuilder};

use warp::Filter;
use tokio::sync::broadcast;

fn main() {
    let logger = Logger::new(LOG_FILE);
    
    unsafe {
        std::env::set_var("RUST_LOG", "warp=info");
        std::env::set_var("WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS", "--disable-web-security --allow-file-access-from-files --allow-running-insecure-content --autoplay-policy=no-user-gesture-required");
    }

    let (reload_tx, _) = broadcast::channel::<()>(16);
    let _ = RELOAD_SIGNAL.set(reload_tx.clone());
    let reload_tx_server = reload_tx.clone();

    thread::spawn(move || {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async move {
            loop {
                let app_config = AppConfig::load();
                let server_root = app_config.media_path.clone();
                println!("\nüåç SERVEUR : Initialisation...");

                let mut rx = reload_tx_server.subscribe();
                
                let base_route = warp::path("media")
                    .and(warp::fs::dir(server_root));

                let mut drives_filter: Option<warp::filters::BoxedFilter<(warp::fs::File,)>> = None;

                for letter in b'A'..=b'Z' {
                    let char_letter = letter as char;
                    let drive_path = format!("{}:\\", char_letter);

                    if Path::new(&drive_path).exists() {
                        println!("‚úÖ Disque d√©tect√© et mont√© : {} (Route: /drives/{})", drive_path, char_letter.to_lowercase());
                        
                        let this_drive = warp::path("drives")
                            .and(warp::path(char_letter.to_lowercase().to_string())) // "e"
                            .and(warp::fs::dir(drive_path));

                        drives_filter = match drives_filter {
                            Some(prev) => Some(prev.or(this_drive).unify().boxed()),
                            None => Some(this_drive.boxed()),
                        };
                    }
                }

                let final_drives_route = drives_filter.unwrap_or_else(|| {
                    warp::path("impossible_fallback_route")
                        .and(warp::fs::dir("."))
                        .boxed()
                });

                let cors = warp::cors().allow_any_origin().allow_methods(vec!["GET", "HEAD"]);
                
                let log = warp::log("warp::server");

                let routes = base_route
                    .or(final_drives_route)
                    .unify()
                    .with(cors)
                    .with(log);

                println!("üöÄ SERVEUR PR√äT sur http://127.0.0.1:3030");

                let (_addr, server) = warp::serve(routes)
                    .bind_with_graceful_shutdown(([127, 0, 0, 1], 3030), async move {
                        let _ = rx.recv().await;
                    });

                server.await;
                println!("üîÑ SERVEUR : Red√©marrage...");
                tokio::time::sleep(Duration::from_millis(1000)).await;
            }
        });
    });

    let window = WindowBuilder::new().with_title("NeoKodi").with_resizable(true).with_maximized(true);
    let config_dioxus = Config::new().with_window(window).with_custom_head(format!("<style>{}</style>", GLOBAL_STYLE));

    LaunchBuilder::new().with_cfg(config_dioxus).launch(App);
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/media/audio.rs
// ---------------------------------------------------------
/*
in this file we handle audio playback
*/

use super::data::{Media, MediaType, MediaInfo};

use lofty::prelude::*; 
use lofty::read_from_path;

// use std::fs::File; // Plus besoin
// use std::io::BufReader; // Plus besoin
use rand::seq::SliceRandom;
use rand::thread_rng;

use crate::logger::logger::Logger;
use crate::constants::LOG_FILE;

// --- STRUCTURE METADATA ---
pub struct Metadata {
    pub title: Option<String>,
    pub artist: Option<String>,
    pub album: Option<String>,
    pub duration: f32,
}

impl Metadata {
    pub fn from_path(path: &str) -> Self {
        match read_from_path(path) {
            Ok(tagged_file) => {
                let properties = tagged_file.properties();
                let tag = tagged_file.primary_tag();

                Metadata {
                    duration: properties.duration().as_secs_f32(),
                    title: tag.and_then(|t| t.title().map(|s| s.to_string())),
                    artist: tag.and_then(|t| t.artist().map(|s| s.to_string())),
                    album: tag.and_then(|t| t.album().map(|s| s.to_string())),
                }
            },
            Err(_) => Metadata {
                duration: 0.0,
                title: None,
                artist: None,
                album: None,
            }
        }
    }
}

// --- QUEUE (Inchang√©) ---
pub struct Queue {
    audio_queue: Vec<i64>,
    original_queue: Vec<i64>,
    repeat: bool,
}

impl Queue {
    pub fn new() -> Self {
        Queue {
            audio_queue: Vec::new(),
            original_queue: Vec::new(),
            repeat: false,
        }
    }

    pub fn add_to_queue(&mut self, media: i64) {
        let logger = Logger::new(LOG_FILE);
        self.audio_queue.push(media);
        self.original_queue.push(media);
        logger.debug(&format!("Added to queue: {}", media));
    }

    pub fn get_current(&self) -> Option<i64> {
        self.audio_queue.first().cloned()
    }

    pub fn next(&mut self) -> Option<i64> {
        let logger = Logger::new(LOG_FILE);
        
        if !self.audio_queue.is_empty() {
            let next_media = self.audio_queue.remove(0);
            logger.info(&format!("Next media in queue: {}", next_media));
            Some(next_media)
        } else {
            if self.repeat && !self.original_queue.is_empty() {
                self.audio_queue = self.original_queue.clone();
                logger.info("Queue is empty, repeating original queue");
                return self.get_current();
            }
            logger.info("Trying to get next media but queue is empty");
            None
        }
    }

    pub fn toggle_shuffle(&mut self) {
        let logger = Logger::new(LOG_FILE);
        if self.audio_queue.is_empty() { return; }
        let mut rng = thread_rng();
        self.audio_queue.shuffle(&mut rng);
        logger.info("Queue shuffled");
    }

    pub fn toggle_repeat(&mut self) {
        self.repeat = !self.repeat;
    }

    pub fn clear_queue(&mut self) {
        self.audio_queue.clear();
        self.original_queue.clear();
    }
}

// --- STRUCTURE AUDIO (NETTOY√âE) ---
pub struct Audio {
    pub id: i64,
    pub path: String,
    pub name: String,
    pub metadata: Metadata, 
    pub last_position: f32,
    // Plus de champs Sink/Stream !
}

impl Audio {
    pub fn new(id: i64, path: &str, name: &str, last_pos: f32) -> Self {
        let metadata = Metadata::from_path(path);
        Self {
            id,
            path: path.to_string(),
            name: name.to_string(),
            metadata,
            last_position: last_pos,
        }
    }
}

// üëá C'EST ICI LA MAGIE : ON NE FAIT RIEN EN RUST
// On laisse l'interface HTML g√©rer le vrai son.
impl Media for Audio {
    fn init(&mut self) {
    }

    fn play(&mut self) {
        println!("‚ñ∂Ô∏è Audio s√©lectionn√© (Played by Frontend): {}", self.name);
    }

    fn pause(&self) {
    }

    fn resume(&self) {
    }

    fn stop(&self) {
    }
    
    fn info(&self) -> MediaInfo {
        MediaInfo {
            id: self.id,
            path: self.path.clone(),
            title: Some(self.name.clone()),
            artist: self.metadata.artist.clone(),
            duration: Some(self.metadata.duration),
            media_type: MediaType::Audio,
            last_position: self.last_position,
            tags: Vec::new(),
        }
    }
    
    fn media_type(&self) -> MediaType {
        MediaType::Audio
    }

    fn get_name(&self) -> String {
        self.name.clone()
    }

    fn get_path(&self) -> String {
        self.path.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    fn sample_path() -> Option<String> {
        let p = Path::new("tests/data/sample.mp3");
        if p.exists() { Some(p.to_string_lossy().to_string()) } else { None }
    }

    #[test]
    fn new_reads_metadata() {
        if let Some(path) = sample_path() {
            let audio = Audio::new(1, &path, "Sample", 0.0);
            assert_eq!(audio.media_type(), MediaType::Audio);
            assert_eq!(audio.id, 1);
        }
    }

    #[test]
    fn info_returns_media_info() {
        if let Some(path) = sample_path() {
            let audio = Audio::new(1, &path, "Sample", 10.5);
            let info = audio.info();
            assert_eq!(info.path, path);
            assert_eq!(info.last_position, 10.5);
            assert!(info.tags.is_empty());
        }
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/media/data.rs
// ---------------------------------------------------------

use std::fmt;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum MediaType {
    Audio,
    Video,
    Image,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MediaInfo {
    pub id: i64,
    pub path: String,
    pub title: Option<String>,
    pub artist: Option<String>,
    pub duration: Option<f32>,
    pub media_type: MediaType,
    pub last_position: f32,
        #[serde(default)]
    pub tags: Vec<String>,
}

impl MediaType {
    pub fn from_db(value: &str) -> Option<Self> {
        match value {
            "Video" => Some(MediaType::Video),
            "Audio" => Some(MediaType::Audio),
            "Image" => Some(MediaType::Image),
            _ => Some(MediaType::Image),
        }
    }

    pub fn as_db(&self) -> &'static str {
        match self {
            MediaType::Video => "video",
            MediaType::Audio => "audio",
            MediaType::Image => "image",
        }
    }
}


impl fmt::Display for MediaType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MediaType::Audio => write!(f, "Audio"),
            MediaType::Video => write!(f, "Video"),
            MediaType::Image => write!(f, "Image"),
        }
    }
}

//TODO: implement finished event handling
pub trait Media: Send + Sync {
    fn init(&mut self);
    
    fn play(&mut self);
    fn pause(&self);
    fn resume(&self);
    fn stop(&self);

    fn info(&self) -> MediaInfo;
    fn media_type(&self) -> MediaType;

    //debug
    fn get_name(&self) -> String;
    fn get_path(&self) -> String;
}


// ---------------------------------------------------------
// FILE: ./EpiKodi/src/media/image.rs
// ---------------------------------------------------------
use super::data::Media;
use super::data::MediaType;
use super::data::MediaInfo;

use crate::logger::logger::Logger;
use crate::constants::LOG_FILE;

pub struct Image {
    pub id: i64,
    pub path: String,
    pub name: String,
    pub media_type: MediaType,
}

impl Image {
    pub fn new(id: i64, path: &str, name: &str) -> Self {
        Self {
            id,
            path: path.to_string(),
            name: name.to_string(),
            media_type: MediaType::Image,
        }
    }
}

impl Media for Image {
    fn init(&mut self) {}

    fn play(&mut self) {

        let logger = Logger::new(LOG_FILE);

        logger.debug(&format!("Playing image: {}", self.name));
    }

    fn pause(&self) {}
    fn resume(&self) {}
    fn stop(&self) {}

    fn info(&self) -> MediaInfo {
        MediaInfo {
            id: self.id,
            path: self.path.clone(),
            title: Some(self.name.clone()),
            artist: None,
            duration: None,
            media_type: MediaType::Image,
            last_position: 0.0,
            tags: Vec::new(), 
        }
    }

    fn media_type(&self) -> MediaType { MediaType::Image }
    fn get_name(&self) -> String { self.name.clone() }
    fn get_path(&self) -> String { self.path.clone() }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/media/mod.rs
// ---------------------------------------------------------
pub mod data;

pub mod video;
pub mod audio;
pub mod image;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/media/video.rs
// ---------------------------------------------------------
/* src/media/video.rs */

use super::data::Media;
use super::data::MediaType;
use super::data::MediaInfo;

use crate::logger::logger::Logger;
use crate::constants::LOG_FILE;

// On garde une structure simple pour les m√©tadonn√©es (optionnel pour l'instant)
#[derive(Clone)]
pub struct VideoMetadata {
    pub duration: f32,
    // On pourra remettre realisateur/ann√©e plus tard
}

pub struct Video {
    pub id: i64,
    pub last_position: f32,
    pub path: String,
    pub name: String,
    pub metadata: VideoMetadata,
}

impl Video {
    pub fn new(id: i64, path: &str, name: &str, last_position: f32, duration: f32) -> Self {
        Self {
            id,
            last_position,
            path: path.to_string(),
            name: name.to_string(),
            metadata: VideoMetadata {
            duration: duration,
            }
        }
    }
}

impl Media for Video {
    fn init(&mut self) {}

    fn play(&mut self) {
        let logger = Logger::new(LOG_FILE);
        logger.debug(&format!("Playing video: {}", self.name));
    }

    fn pause(&self) {}
    fn resume(&self) {}
    fn stop(&self) {}

    fn info(&self) -> MediaInfo {
        MediaInfo {
            id: self.id,
            path: self.path.clone(),
            title: Some(self.name.clone()),
            artist: None,
            duration: Some(self.metadata.duration),
            media_type: MediaType::Video,
            last_position: self.last_position,
            tags: Vec::new(),
        }
    }

    fn media_type(&self) -> MediaType { MediaType::Video }
    fn get_name(&self) -> String { self.name.clone() }
    fn get_path(&self) -> String { self.path.clone() }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/plugin/functions.rs
// ---------------------------------------------------------
/*


*/

use std::os::raw::c_char;

pub type GreetFunc = unsafe extern "C" fn(*const c_char) -> *mut c_char;
pub type GetArtistMetadataFunc = unsafe extern "C" fn(*const c_char) -> *mut c_char;
pub type GetFilmMetadataFunc = unsafe extern "C" fn(*const c_char) -> *mut c_char;

pub type NameFunc = unsafe extern "C" fn() -> *mut c_char;
pub type VersionFunc = unsafe extern "C" fn() -> *mut c_char;
pub type FreeStringFunc = unsafe extern "C" fn(*mut c_char);
pub type PluginTypeFunc = unsafe extern "C" fn() -> *mut c_char;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/plugin/mod.rs
// ---------------------------------------------------------
pub mod plugin_manager;
pub mod functions;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/plugin/plugin_manager.rs
// ---------------------------------------------------------
use libloading::{Library, Symbol};
use std::fs;
use std::ffi::{CStr, CString};
use std::path::PathBuf;
use crate::constants::{PLUGIN_DIR, PLUGIN_EXT};

// Assure-toi que ces types sont bien d√©finis dans functions.rs
use super::functions::PluginTypeFunc;
use super::functions::GetArtistMetadataFunc;
use super::functions::GetFilmMetadataFunc;

use crate::logger::logger::Logger;
use crate::constants::LOG_FILE;

pub struct PluginManager {
    pub metadata_libs: Vec<Library>,
    pub film_metadata_libs: Vec<Library>,
}

impl PluginManager {
    pub fn new() -> Self {
        PluginManager {
            metadata_libs: Vec::new(),
            film_metadata_libs: Vec::new(),
        }
    }

    pub fn load_plugins(&mut self) {
        // 1. On initialise le logger ICI pour pouvoir l'utiliser
        let logger = Logger::new(LOG_FILE);
        
        println!("üîå [PLUGIN] D√©marrage du chargement des plugins...");
        
        if let Ok(cwd) = std::env::current_dir() {
            println!("üìÇ [PLUGIN] Dossier de travail actuel : {:?}", cwd);
        }

        let plugin_path = PathBuf::from(PLUGIN_DIR);
        if !plugin_path.exists() {
            println!("‚ùå [PLUGIN] Le dossier '{}' n'existe pas !", PLUGIN_DIR);
            return;
        }

        if let Ok(paths) = fs::read_dir(plugin_path) {
            for entry in paths.flatten() {
                let path = entry.path();
                
                let is_plugin = path.extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| PLUGIN_EXT.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);

                if is_plugin {
                    println!("üîé [PLUGIN] Tentative de chargement : {:?}", path);

                    // CHARGEMENT DLL
                    let lib = match unsafe { Library::new(&path) } {
                        Ok(l) => {
                            println!("‚úÖ [PLUGIN] DLL charg√©e en m√©moire !");
                            l
                        },
                        Err(e) => {
                            logger.error(&format!("‚úó √âCHEC chargement DLL : {}", e));
                            continue;
                        }
                    };

                    // V√âRIFICATION DU TYPE
                    unsafe {
                        let get_plugin_type: Result<Symbol<PluginTypeFunc>, _> = lib.get(b"plugin_type\0");
                        
                        match get_plugin_type {
                            Ok(func) => {
                                let type_ptr = func();
                                let result = CStr::from_ptr(type_ptr).to_str().unwrap_or("Error");
                                
                                println!("‚ÑπÔ∏è [PLUGIN] Type d√©tect√© : '{}'", result);

                                match result {
                                    "metadata" => {
                                        self.metadata_libs.push(lib);
                                        logger.info("Loaded metadata plugin.");
                                    },
                                    "film_metadata" => {
                                        self.film_metadata_libs.push(lib);
                                        logger.info("Loaded film metadata plugin.");
                                    },
                                    _ => {
                                        logger.error(&format!("‚úó Unknown plugin type: {}", result));
                                    }
                                }
                            },
                            Err(e) => {
                                logger.error(&format!("‚úó Failed to load 'plugin_type' function: {} ", e));
                                continue;
                            }
                        };
                    }
                }
            }
        }
    }

    // Changement ici : on renvoie String, pas &str
    pub fn get_metadata(&mut self, artist: &str) -> String {
        let logger = Logger::new(LOG_FILE);
        let c_artist = CString::new(artist).unwrap();

        for lib in &self.metadata_libs {
            unsafe {
                let get_metadata_func: Result<Symbol<GetArtistMetadataFunc>, _> = lib.get(b"metadata\0");

                match get_metadata_func {
                    Ok(func) => {
                        // On appelle la fonction de la DLL
                        let metadata_ptr = func(c_artist.as_ptr());
                        let result = CStr::from_ptr(metadata_ptr).to_str().unwrap_or("Error UTF8");
                        
                        if result == "artist not found" {
                            continue; // On essaye le plugin suivant
                        }
                        
                        // On a trouv√© ! On renvoie une String propre
                        return result.to_string();
                    },
                    Err(e) => {
                        logger.error(&format!("‚úó Failed to load 'metadata' function: {}", e));
                        continue;
                    }
                };
            }
        }
        return "artist not found".to_string();
    }

    // Changement ici aussi : on renvoie String
    // Dans src/plugin/plugin_manager.rs

    pub fn get_film_metadata(&mut self, film: &str) -> String {
        let logger = Logger::new(LOG_FILE);
        let c_film = CString::new(film).unwrap();

        // üëá DEBUG : Combien de plugins de films sont charg√©s ?
        println!("üéûÔ∏è [MANAGER] Nombre de plugins 'film' charg√©s : {}", self.film_metadata_libs.len());

        for lib in &self.film_metadata_libs {
            unsafe {
                let get_film_metadata: Result<Symbol<GetFilmMetadataFunc>, _> = lib.get(b"metadata\0");

                match get_film_metadata {
                    Ok(func) => {
                        println!("üöÄ [MANAGER] Appel de la DLL TMDB pour '{}'...", film);
                        let metadata_ptr = func(c_film.as_ptr());
                        let result = CStr::from_ptr(metadata_ptr).to_str().unwrap_or("Error UTF8");
                        
                        println!("üì• [MANAGER] R√©ponse de la DLL : {}", result);

                        if result == "film not found" {
                             continue;
                        }
                        return result.to_string();
                    },
                    Err(e) => {
                        logger.error(&format!("‚úó Failed to load 'metadata' (film) function: {}", e));
                        continue;
                    }
                }
            }
        }
        println!("‚ùå [MANAGER] Aucun plugin n'a trouv√© le film (ou aucun plugin charg√©).");
        return "film not found".to_string();
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/scan/mod.rs
// ---------------------------------------------------------
pub mod scan;

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/scan/scan.rs
// ---------------------------------------------------------
/*

*/

use crate::library::sources::LibraryConfig;
use crate::library::media_library::ScannedMedia;
use crate::media::data::MediaType;

use crate::constants::{SOURCE_FILE, AUDIO_EXTS, VIDEO_EXTS, IMAGE_EXTS};

use crate::logger::logger::Logger;
use crate::constants::{LOG_FILE, LOG_FILE_MEDIA_ITEMS};

use std::path::Path;
use std::fs;


pub struct Scan {
    pub libraries: LibraryConfig,
    pub scan: Vec<ScannedMedia>,
}

impl Scan {
    pub fn new() -> Self {
        Self {
            libraries: LibraryConfig::load(SOURCE_FILE),
            scan: Vec::new(),
        }
    }

    pub fn scan_libraries(&mut self) {

        let logger = Logger::new(LOG_FILE);

        //=========== SCAN SOURCES ===========

        let music_source_paths: Vec<_> = self.libraries.music_sources.iter().map(|source| source.path.clone()).collect();
        let video_source_paths: Vec<_> = self.libraries.video_sources.iter().map(|source| source.path.clone()).collect();
        let image_source_paths: Vec<_> = self.libraries.image_sources.iter().map(|source| source.path.clone()).collect();

        logger.info("Scanning sources ...");
        for path in music_source_paths {
            logger.info(&format!("Scanning: {}", path.display()));
            self.scan_audio_libraries(&path);
        }
        for path in video_source_paths {
            logger.info(&format!("Scanning: {}", path.display()));
            self.scan_video_libraries(&path);
        }
        for path in image_source_paths {
            logger.info(&format!("Scanning: {}", path.display()));
            self.scan_image_libraries(&path);
        }
        logger.info("Scanning sources end");

        self.debug_print_items();
    }
    
    fn scan_audio_libraries(&mut self, folder: &Path) {
        if let Ok(entries) = fs::read_dir(folder) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_dir() {
                    // Recurse
                    self.scan_audio_libraries(&path);
                    continue;
                }

                // Extension check
                let is_audio = path
                    .extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| AUDIO_EXTS.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);

                if is_audio {
                    self.scan.push(ScannedMedia {
                        path: path.to_string_lossy().to_string(),
                        name: path
                            .file_name()
                            .unwrap()
                            .to_string_lossy()
                            .to_string(),
                        duration: 0.0, //TODO: get duration
                        media_type: MediaType::Audio,
                    });
                }
            }
        }
    }

    pub fn scan_video_libraries(&mut self, folder: &Path) {
        
        if let Ok(entries) = fs::read_dir(folder) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_dir() {
                    // Recurse
                    self.scan_video_libraries(&path);
                    continue;
                }

                let is_video = path
                    .extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| VIDEO_EXTS.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);

                if is_video {
                    self.scan.push(ScannedMedia {
                        path: path.to_string_lossy().to_string(),
                        name: path
                            .file_name()
                            .unwrap()
                            .to_string_lossy()
                            .to_string(),
                        duration: 0.0, //TODO: get duration
                        media_type: MediaType::Video,
                    });
                }
            }
        }
    }

    pub fn scan_image_libraries(&mut self, folder: &Path) {
        if let Ok(entries) = fs::read_dir(folder) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_dir() {
                    // Recurse
                    self.scan_image_libraries(&path);
                    continue;
                }

                // Extension check
                let is_image = path
                    .extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| IMAGE_EXTS.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);

                if is_image {
                    self.scan.push(ScannedMedia {
                        path: path.to_string_lossy().to_string(),
                        name: path
                            .file_name()
                            .unwrap()
                            .to_string_lossy()
                            .to_string(),
                        duration: 0.0, //TODO: get duration
                        media_type: MediaType::Image,
                    });
                }
            }
        }
    }

    // pour afficher la liste des items dans la bibliotheque
    //TODO : a enlever plus tard, c'est juste pour debug
    pub fn debug_print_items(&self) {

        let logger = Logger::new(LOG_FILE_MEDIA_ITEMS);
        logger.debug("=== Library Content start ===");

        for item in &self.scan {
            logger.debug(&format!("{} - {} ({})", item.media_type.to_string(), item.name, item.path));
        }

        logger.debug("=== Library Content end ===");
    }

}















#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::time::{SystemTime, UNIX_EPOCH};

    // Creates a unique temp directory for each test.
    fn temp_dir(label: &str) -> std::path::PathBuf {
        let stamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        let dir = std::env::temp_dir().join(format!("epikodi_scan_{label}_{stamp}"));
        fs::create_dir_all(&dir).unwrap();
        dir
    }

    #[test]
    fn scan_audio_libraries_collects_audio_files() {
        let dir = temp_dir("audio");
        fs::write(dir.join("song.mp3"), b"").unwrap();
        fs::write(dir.join("note.txt"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_audio_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert_eq!(scan.scan[0].media_type, MediaType::Audio);
        assert!(scan.scan[0].path.ends_with("song.mp3"));

        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn scan_video_libraries_collects_video_files() {
        let dir = temp_dir("video");
        fs::write(dir.join("movie.mp4"), b"").unwrap();
        fs::write(dir.join("readme.md"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_video_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert_eq!(scan.scan[0].media_type, MediaType::Video);
        assert!(scan.scan[0].path.ends_with("movie.mp4"));

        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn scan_image_libraries_collects_image_files() {
        let dir = temp_dir("image");
        fs::write(dir.join("cover.jpg"), b"").unwrap();
        fs::write(dir.join("doc.pdf"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_image_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert_eq!(scan.scan[0].media_type, MediaType::Image);
        assert!(scan.scan[0].path.ends_with("cover.jpg"));

        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn scan_audio_libraries_recurse_into_subdirs() {
        let dir = temp_dir("audio_nested");
        let sub = dir.join("sub");
        fs::create_dir_all(&sub).unwrap();
        fs::write(sub.join("nested.mp3"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_audio_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert!(scan.scan[0].path.ends_with("nested.mp3"));

        let _ = fs::remove_dir_all(dir);
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/threading/command.rs
// ---------------------------------------------------------

/*
This file defines commands and events for media playback control.
*/
use crate::media::data::MediaType;
use std::path::PathBuf;
use crate::media::data::MediaInfo;

pub enum Command {
    ChangeLibraryPath(PathBuf),

    AddSource(PathBuf, MediaType), // path, media type
    RemoveSource(PathBuf, MediaType), // path, media type
    Reload(),
    /*
    TODO

    RemoveSource(PathBuf), // path
    //ScanLibrary, // allows the user to rescan the library todo: add options like full scan or quick scan, 
    ajouter un fichier de config, 
    scanner seulement la premiere fois et puis tous les x jours ou sur un bouton
    ajouter des logs
    */
            

    GetMediaFromPath(PathBuf), // path
    GetAllMedia(),
    GetMediaFromType(MediaType), // media type
    GetMediaFromTag(String), // tag name
    GetMediaFromPlaylist(i64), // playlist id
    UpdateMediaState(i64, i32, f64), // media id, status, time_stop
    /*
    TODO:
    R√©cup√©ration automatique d'informations suppl√©mentaires sur les m√©dias (affiches, synopsis, note, casting) depuis des bases de donn√©es en ligne.
    */

    Play(i64), // media id
    Pause(i64), // media id 
    Resume(i64), // media id
    Stop(i64), // media id
    Info(i64), // media id
    UpdateProgress(i64, f32, f32),
    /*
    TODO:
    Avance rapide / Retour rapide (¬±10 secondes)
    Contr√¥le du volume (0-100%)
    Barre de progression avec seek (clic pour aller √† un moment pr√©cis)
    file d'attente de lecture (playlist dynamique)
    lecture aleatoire
    repeat
    */
    //ActuaizeMedia       //if a user want to change at what time he is in a media

    AddTag(String), // tag name
    GetTagId(String), // tag name
    AddTagToMedia(i64, i64), // media_id, tag_id
    RemoveTagFromMedia(i64, i64), // media_id, tag_id
    DeleteTag(i64), // tag_id
    GetAllTags(), // returns Vec<(tag_id, tag_name)>
    /*
    TODO:

    */
    //RemoveTag(String),

    AddPlaylist(String), // playlist name
    GetPlaylistId(String), // playlist name
    AddMediaToPlaylist(i64, i64), // media_id, playlist_id
    RemoveMediaFromPlaylist(i64, i64), // media_id, playlist_id
    DeletePlaylist(i64), // playlist_id
    GetAllPlaylists(), // returns Vec<(playlist_id, playlist_name)>
    /*
    TODO:
    delete playlist
    */

    GetArtistMetadataFromPlugin(String), // artist name
    GetfilmMetadataFromPlugin(String), // artist name
    GetPluginHistory,

}

pub enum Event {
    Finished(i64),
    NowPlaying(i64),
    Data(String),
    Info(MediaInfo),
    IDList(Vec<i64>),
    MediaList(Vec<MediaInfo>),
    M3UList(Vec<crate::iptv::parser::TVChannel>),
    PlaylistList(Vec<(i64, String)>),
    PluginDataReceived(String),
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/threading/media_thread.rs
// ---------------------------------------------------------

/*
This file manages the media thread, which handles media playback commands
*/


use crate::library::media_library::MediaLibrary;
use super::command::Command;
use super::command::Event;
use crate::media::data::MediaType;

use crate::plugin::plugin_manager::PluginManager;




use std::thread;
use std::sync::{Arc, Mutex, mpsc};
use std::path::PathBuf;

pub fn launch_media_thread(cmd_rx: mpsc::Receiver<Command>, evt_tx: mpsc::Sender<Event>) {

    let library = Arc::new(Mutex::new(MediaLibrary::new()));
    let lib_thread = Arc::clone(&library);
    let mut plugin_manager = PluginManager::new();
    plugin_manager.load_plugins();
    
    // let media_thread =
    thread::spawn(move || {
        let mut library = lib_thread.lock().unwrap();
        library.init();


        // ----TESTS----
        //library.play_id(3);
        //library.update_media_status_and_time(1, PLAYING, 100.0);






        drop(library);

        loop {
            // TODO handle errors
            match cmd_rx.recv() {
                // le mutex se drop en sortant du scope
                
                //TODO - virer cette merde
                // this thing is a heresy.... can't stay like this
                Ok(Command::ChangeLibraryPath(path)) => {
                   // println!("üîÑ RE√áU COT√â BACKEND : CHANGEMENT DE RACINE vers {:?}", path);
                    let mut library = lib_thread.lock().unwrap();

                    library.clear();

                    evt_tx.send(Event::MediaList(Vec::new())).unwrap();

                    library.add_source(path.clone(), MediaType::Video);
                    library.add_source(path.clone(), MediaType::Audio);
                    library.add_source(path, MediaType::Image);

                    evt_tx.send(Event::MediaList(library.get_all_media())).unwrap();
                }



                Ok(Command::AddSource(path, media_type)) => {
                    let mut library = lib_thread.lock().unwrap();
                    
                    library.add_source(path, media_type);
                }

                Ok(Command::RemoveSource(path, media_type)) => {
                    let mut library = lib_thread.lock().unwrap();
                    
                    library.remove_source(path, media_type);
                }

                Ok(Command::GetAllMedia()) => {
                    let library = lib_thread.lock().unwrap();
                    let media_list = library.get_all_media();
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::GetMediaFromPath(path)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let media_list = library.get_media_from_path(path);
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::GetMediaFromType(media_type)) => {
                    let library = lib_thread.lock().unwrap();
                    let media_list = library.get_media_by_type(media_type);
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::GetMediaFromTag(tag_name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let media_list = library.get_media_from_tag(&tag_name);
                    // For simplicity, we just send the count of media items found
                    evt_tx.send(Event::IDList(media_list)).unwrap();
                }

                Ok(Command::UpdateMediaState(media_id, status, time_stop)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.update_media_status_and_time(media_id, status, time_stop, 0.0);
                }

                Ok(Command::Reload()) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.reload();
                    let media_list = library.get_all_media();
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::Play(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.play_id(id);
                    evt_tx.send(Event::NowPlaying(id)).unwrap();
                }

                Ok(Command::Pause(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.pause_id(id);
                }

                Ok(Command::Resume(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.resume_id(id);
                    evt_tx.send(Event::NowPlaying(id)).unwrap();
                }

                Ok(Command::Stop(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.stop_id(id);
                }

                Ok(Command::Info(id)) => {
                    let library = lib_thread.lock().unwrap();
                    let info = library.info_id(id).unwrap();
                    evt_tx.send(Event::Info(info)).unwrap();
                }

                Ok(Command::AddTag(tag_name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.add_tag(&tag_name);
                }

                Ok(Command::GetTagId(tag_name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let tag_id = library.get_tag_id(&tag_name);
                    evt_tx.send(Event::Data(tag_id.to_string())).unwrap();
                }

                Ok(Command::AddTagToMedia(media_id, tag_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.add_tag_to_media(media_id, tag_id);
                }

                Ok(Command::RemoveTagFromMedia(media_id, tag_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.remove_tag_from_media(media_id, tag_id);
                }

                Ok(Command::DeleteTag(tag_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.remove_tag(tag_id);
                }

                Ok(Command::GetAllTags()) => {
                    let mut library = lib_thread.lock().unwrap();
                    let tags = library.get_all_tags();
                    // For simplicity, we just send the count of tags found
                    evt_tx.send(Event::IDList(tags.into_iter().map(|(id, _)| id).collect())).unwrap();
                }

                Ok(Command::AddPlaylist(name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.create_playlist(&name);
                }

                Ok(Command::AddMediaToPlaylist(media_id, playlist_id)) => {
                    println!("üî• [THREAD] AJOUT: Media {} -> Playlist {}", media_id, playlist_id);
                    let mut library = lib_thread.lock().unwrap();
                    library.add_media_to_playlist(media_id, playlist_id);
                }

                Ok(Command::GetPlaylistId(_)) => {
                // On ne fait rien pour l'instant, mais il faut le g√©rer
                }

                Ok(Command::DeletePlaylist(playlist_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.delete_playlist(playlist_id);
                }

                Ok(Command::RemoveMediaFromPlaylist(media_id, playlist_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.remove_media_from_playlist(media_id, playlist_id);
                }

                Ok(Command::GetMediaFromPlaylist(playlist_id)) => {
                    println!("üî• [THREAD] LECTURE: Contenu Playlist {}", playlist_id);
                    
                    let mut library = lib_thread.lock().unwrap();
                    let ids = library.get_media_from_playlist(playlist_id);
                    
                    println!("üî• [THREAD] IDs trouv√©s: {:?}", ids);
                    
                    evt_tx.send(Event::IDList(ids)).unwrap();
                }

                Ok(Command::GetAllPlaylists()) => {
                    let mut library = lib_thread.lock().unwrap();
                    let playlists = library.get_all_playlists();
                    evt_tx.send(Event::PlaylistList(playlists)).unwrap();
                }

                Ok(Command::GetPluginHistory) => {
                    let lib = lib_thread.lock().unwrap();
                    if let Ok(history) = lib.database.get_all_artist_metadata() {
                        for entry in history {
                            evt_tx.send(Event::PluginDataReceived(entry)).unwrap();
                        }
                    }
                },

                Ok(Command::GetArtistMetadataFromPlugin(name)) => {
                    let mut lib = lib_thread.lock().unwrap();
                    let history = lib.database.get_all_artist_metadata().unwrap_or_default();
                    
                    if let Some(cached) = history.iter().find(|h| h.contains(&name)) {
                        evt_tx.send(Event::PluginDataReceived(cached.clone())).unwrap();
                    } else {
                        drop(lib);
                        let response = plugin_manager.get_metadata(name.as_str());
                        
                        let mut lib = lib_thread.lock().unwrap();
                        let _ = lib.database.save_artist_metadata(&name, &response);
                        evt_tx.send(Event::PluginDataReceived(response)).unwrap();
                    }
                }

                Ok(Command::GetfilmMetadataFromPlugin(name)) => {
                    let response = plugin_manager.get_film_metadata(name.as_str());
                    evt_tx.send(Event::PluginDataReceived(response)).unwrap();
                }

                Ok(Command::UpdateProgress(id, pos, total_duration)) => {
                    if let Ok(mut lib) = crate::library::media_library::MEDIA_LIBRARY.write() {
                        if let Some(media) = lib.iter_mut().find(|m| m.id == id) {
                            media.last_position = pos;
                            if total_duration > 0.0 { media.duration = Some(total_duration); }
                        }
                    }

                    let mut library = lib_thread.lock().unwrap();
                    library.update_media_status_and_time(id, 1, pos as f64, total_duration); 
                },

                Err(_) => break,
            }
        }
    });
}






#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::mpsc;
    use std::thread;
    use std::time::Duration;

    fn setup_thread() -> (mpsc::Sender<Command>, mpsc::Receiver<Event>) {
        let (cmd_tx, cmd_rx) = mpsc::channel();
        let (evt_tx, evt_rx) = mpsc::channel();

        launch_media_thread(cmd_rx, evt_tx);

        thread::sleep(Duration::from_millis(100));

        (cmd_tx, evt_rx)
    }

    #[test]
    fn test_add_source_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        let path = PathBuf::from("/test/music");
        
        cmd_tx.send(Command::AddSource(path, crate::media::data::MediaType::Audio)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_get_all_media_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetAllMedia()).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::MediaList(_)) => {},
            _ => panic!("Expected MediaList event"),
        }
    }

    #[test]
    fn test_get_media_from_path_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        let path = PathBuf::from("/test");
        
        cmd_tx.send(Command::GetMediaFromPath(path)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::MediaList(_)) => {},
            _ => panic!("Expected MediaList event"),
        }
    }

    #[test]
    fn test_get_media_from_type_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetMediaFromType(crate::media::data::MediaType::Audio)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::MediaList(_)) => {},
            _ => panic!("Expected MediaList event"),
        }
    }

    #[test]
    fn test_get_media_from_tag_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetMediaFromTag("action".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::IDList(_)) => {},
            _ => panic!("Expected IDList event"),
        }
    }

    #[test]
    fn test_get_media_from_playlist_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetMediaFromPlaylist(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::IDList(_)) => {},
            _ => panic!("Expected IDList event"),
        }
    }

    #[test]
    fn test_play_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Play(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::NowPlaying(id)) => assert_eq!(id, 1),
            _ => panic!("Expected NowPlaying event"),
        }
    }

    #[test]
    fn test_pause_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Pause(1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_resume_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Resume(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::NowPlaying(id)) => assert_eq!(id, 1),
            _ => panic!("Expected NowPlaying event"),
        }
    }

    #[test]
    fn test_stop_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Stop(1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    #[ignore]
    fn test_info_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Info(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Info(_)) => {},
            _ => panic!("Expected Info event"),
        }
    }

    #[test]
    fn test_add_tag_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddTag("favorite".to_string())).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_get_tag_id_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetTagId("action".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Data(_)) => {},
            _ => panic!("Expected Data event"),
        }
    }

    #[test]
    fn test_add_tag_to_media_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddTagToMedia(1, 1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_add_playlist_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddPlaylist("My Playlist".to_string())).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_add_media_to_playlist_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddMediaToPlaylist(1, 1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_get_playlist_id_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetPlaylistId("My Playlist".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Data(_)) => {},
            _ => panic!("Expected Data event"),
        }
    }

    #[test]
    fn test_thread_exits_on_channel_close() {
        let (cmd_tx, _evt_rx) = setup_thread();
        drop(cmd_tx);
        thread::sleep(Duration::from_millis(100));
        // Thread should exit gracefully
    }

    #[test]
    fn test_multiple_sequential_commands() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddTag("action".to_string())).unwrap();
        cmd_tx.send(Command::GetTagId("action".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Data(_)) => {},
            _ => panic!("Expected Data event"),
        }
    }
}

// ---------------------------------------------------------
// FILE: ./EpiKodi/src/threading/mod.rs
// ---------------------------------------------------------
pub mod media_thread;
pub mod command;

// ---------------------------------------------------------
// FILE: ./plugin_api/Cargo.toml
// ---------------------------------------------------------
[package]
name = "plugin-api"
version = "0.1.0"
edition = "2024"

[dependencies]

// ---------------------------------------------------------
// FILE: ./plugin_api/src/lib.rs
// ---------------------------------------------------------
// This defines the trait that plugins must implement
pub trait Greeter {
    fn greet(&self, name: &str) -> String;
}

pub trait Plugin {
    fn name(&self) -> String;
    fn version(&self) -> String;
    fn plugin_type(&self) -> String; // "metadata",

    //get artist metadata by name
    fn metadata(&self, name: &str) -> String;
}

// ---------------------------------------------------------
// FILE: ./plugin_music/cargo.toml
// ---------------------------------------------------------
[package]
name = "musicbrainz-plugin"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib"]

[dependencies]
plugin-api = { path = "../plugin_api" }
libloading = "0.8"

ureq = { version = "2.9", features = ["json"] } 
urlencoding = "2.1"

serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

// ---------------------------------------------------------
// FILE: ./plugin_music/src/lib.rs
// ---------------------------------------------------------
use plugin_api::Plugin;
use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use serde::Deserialize;
use std::panic;
use std::time::Duration;

// --- STRUCTURES JSON (Pour lire la r√©ponse de MusicBrainz) ---
#[derive(Deserialize, Debug)]
struct ArtistSearchResult {
    artists: Vec<Artist>,
}

#[derive(Deserialize, Debug)]
struct Artist {
    name: String,
    #[serde(rename = "type")]
    artist_type: Option<String>,
    country: Option<String>,
    #[serde(rename = "life-span")]
    life_span: Option<LifeSpan>,
}

#[derive(Deserialize, Debug)]
struct LifeSpan {
    begin: Option<String>,
    end: Option<String>,
}

// --- COEUR DU PLUGIN ---
struct MusicBrainzMetadata;

impl Plugin for MusicBrainzMetadata {
    fn name(&self) -> String { "MusicBrainz".to_string() }
    fn version(&self) -> String { "1.0.0".to_string() }
    fn plugin_type(&self) -> String { "metadata".to_string() }

    fn metadata(&self, artist_name: &str) -> String {
        // Mouchard interne pour voir si √ßa marche
        println!("DLL [INTERNAL]: Appel metadata() re√ßu pour '{}'", artist_name);
        
        match search_artist(artist_name) {
            Ok(info) => {
                println!("DLL [INTERNAL]: Succ√®s ! Donn√©es r√©cup√©r√©es.");
                info
            },
            Err(e) => {
                println!("DLL [INTERNAL]: Erreur -> {}", e);
                format!("Erreur plugin : {}", e)
            },
        }
    }
}

// --- FONCTION DE RECHERCHE HTTP (Version stable avec UREQ) ---
fn search_artist(name: &str) -> Result<String, Box<dyn std::error::Error>> {
    println!("DLL [INTERNAL]: Pr√©paration requ√™te...");

    let url = format!(
        "https://musicbrainz.org/ws/2/artist/?query=artist:{}&fmt=json&limit=1",
        urlencoding::encode(name)
    );

    // Timeout de 5s pour √©viter que l'application ne g√®le si internet plante
    let agent = ureq::AgentBuilder::new()
        .timeout_read(Duration::from_secs(5))
        .timeout_write(Duration::from_secs(5))
        .build();

    let response = agent.get(&url)
        .set("User-Agent", "NeoKodiPlugin/1.0 (educational-purpose)")
        .call();

    match response {
        Ok(resp) => {
            println!("DLL [INTERNAL]: R√©ponse re√ßue ! Traitement JSON...");
            let result: ArtistSearchResult = resp.into_json()?;

            if let Some(artist) = result.artists.first() {
                // Construction du texte affich√© dans l'appli
                let mut info = format!("üéµ Artiste : {}", artist.name);
                if let Some(t) = &artist.artist_type { info.push_str(&format!("\nType : {}", t)); }
                if let Some(c) = &artist.country { info.push_str(&format!("\nPays : {}", c)); }
                
                if let Some(ls) = &artist.life_span {
                    if let Some(b) = &ls.begin { info.push_str(&format!("\nD√©but : {}", b)); }
                    if let Some(e) = &ls.end { info.push_str(&format!(" - Fin : {}", e)); }
                }
                
                Ok(info)
            } else {
                Ok("Aucun artiste trouv√© sur MusicBrainz.".to_string())
            }
        },
        Err(e) => {
            println!("DLL [INTERNAL]: Echec HTTP -> {:?}", e);
            // On renvoie l'erreur sous forme de texte pour qu'elle s'affiche dans l'appli
            Ok(format!("Erreur de connexion : {:?}", e)) 
        }
    }
}

// --- FONCTIONS EXPORT√âES (Le pont vers l'application) ---
// C'est ce que l'EXE charge. J'ai ajout√© name/version pour √™tre complet.

fn to_c_string(s: String) -> *mut c_char {
    CString::new(s).unwrap_or_default().into_raw()
}

#[unsafe(no_mangle)]
pub extern "C" fn name() -> *mut c_char { to_c_string("MusicBrainz".to_string()) }

#[unsafe(no_mangle)]
pub extern "C" fn version() -> *mut c_char { to_c_string("1.0.0".to_string()) }

#[unsafe(no_mangle)]
pub extern "C" fn plugin_type() -> *mut c_char {
    // S√©curit√© anti-crash
    let result = panic::catch_unwind(|| {
        let p = MusicBrainzMetadata;
        p.plugin_type()
    });
    match result {
        Ok(s) => to_c_string(s),
        Err(_) => to_c_string("error".to_string()),
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn metadata(name_ptr: *const c_char) -> *mut c_char {
    // üõ°Ô∏è FILET DE S√âCURIT√â CRITIQUE
    // Emp√™che le plugin de faire crasher toute l'application en cas de panique
    let result = panic::catch_unwind(|| {
        let artist_name = unsafe {
            if name_ptr.is_null() { "Inconnu" } 
            else { CStr::from_ptr(name_ptr).to_str().unwrap_or("Inconnu") }
        };

        let plugin = MusicBrainzMetadata;
        plugin.metadata(artist_name)
    });

    match result {
        Ok(s) => to_c_string(s),
        Err(_) => to_c_string("üí• ERREUR INTERNE DU PLUGIN".to_string()),
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn free_string(s: *mut c_char) {
    unsafe {
        if !s.is_null() {
            let _ = CString::from_raw(s);
        }
    }
}

// ---------------------------------------------------------
// FILE: ./tmdb_plugin/cargo.toml
// ---------------------------------------------------------
[package]
name = "tmdb-plugin"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
plugin-api = { path = "../plugin_api" }
reqwest = { version = "0.12", features = ["json", "blocking"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
urlencoding = "2.1"

// ---------------------------------------------------------
// FILE: ./tmdb_plugin/src/lib.rs
// ---------------------------------------------------------
use reqwest;
use plugin_api::Plugin;
use serde::{Deserialize, Serialize};
use std::env;
use std::ffi::{CStr, CString};
use std::os::raw::c_char;



// Structs to deserialize the JSON response from TMDb
#[derive(Debug, Serialize, Deserialize)]
struct Movie {
    id: u32,
    title: String,
    #[serde(rename = "release_date")]
    release_date: String,
    overview: String,
    #[serde(rename = "vote_average")]
    vote_average: f32,
}

#[derive(Debug, Serialize, Deserialize)]
struct SearchResponse {
    results: Vec<Movie>,
    page: u32,
    #[serde(rename = "total_results")]
    total_results: u32,
}




#[derive(Deserialize, Debug)]
struct ArtistSearchResult {
    artists: Vec<Artist>,
}

#[derive(Deserialize, Debug)]
struct Artist {
    name: String,
    #[serde(rename = "type")]
    artist_type: Option<String>,
    country: Option<String>,
    #[serde(rename = "life-span")]
    life_span: Option<LifeSpan>,
}

#[derive(Deserialize, Debug)]
struct LifeSpan {
    begin: Option<String>,
    end: Option<String>,
}


struct TMDBMetadata;

impl Plugin for TMDBMetadata {
    fn name(&self) -> String {
        "TMDB".to_string()
    }

    fn version(&self) -> String {
        "1.0.0".to_string()
    }

    fn plugin_type(&self) -> String {
        "film_metadata".to_string()
    }

    fn metadata(&self, film_name: &str) -> String {
        match search_film(film_name) {
            Ok(info) => info,
            Err(e) => format!("Error searching for '{}': {}", film_name, e),
        }
    }
}


fn search_film(name: &str) -> Result<String, Box<dyn std::error::Error>> {
    let movie_query = name;
    // V√©rifie bien que cette cl√© est valide !
    let api_key = "94de72cdcd31f017c82bc13fd54979b0"; 
    
    println!("üîç [TMDB DLL] Recherche lanc√©e pour : '{}'", movie_query);

    let url = format!(
        "https://api.themoviedb.org/3/search/movie?api_key={}&query={}&language=fr-FR", // J'ai ajout√© language=fr-FR pour toi ;)
        api_key,
        urlencoding::encode(&movie_query)
    );

    println!("üåç [TMDB DLL] URL appel√©e : {}", url); // Attention, √ßa affiche ta cl√© API dans la console

    let response = reqwest::blocking::get(&url)?;
    
    // üëá DEBUG DU STATUS HTTP
    let status = response.status();
    println!("üì° [TMDB DLL] Statut HTTP : {}", status);

    if !status.is_success() {
        println!("‚ùå [TMDB DLL] Erreur API !");
        return Ok(format!("Erreur API TMDB: {}", status));
    }
    
    // üëá ON LIT LE JSON BRUT AVANT DE LE PARSER (Crucial pour debug)
    let raw_body = response.text()?; 
    println!("üì¶ [TMDB DLL] R√©ponse brute : {}", raw_body);

    // On re-parse le JSON depuis la string
    let search_results: SearchResponse = serde_json::from_str(&raw_body)?;

    if search_results.results.is_empty() {
        println!("‚ö†Ô∏è [TMDB DLL] Aucun r√©sultat trouv√© dans le JSON.");
        return Ok(format!("Aucun film trouv√© pour '{}'", movie_query));
    } else {
        println!("‚úÖ [TMDB DLL] {} films trouv√©s.", search_results.results.len());
        
        let mut result = String::new();
        for (index, movie) in search_results.results.iter().take(1).enumerate() { 
            result.push_str(&format!("üé¨ {} ({})\n", movie.title, movie.release_date.split('-').next().unwrap_or("????")));
            result.push_str(&format!("‚≠ê Note: {}/10\n", movie.vote_average));
            
            // Tu peux aussi afficher un synopsis un peu plus long si tu n'as qu'un seul film
            let overview = if movie.overview.len() > 500 {
                format!("{}...", &movie.overview[0..500])
            } else {
                movie.overview.clone()
            };
            result.push_str(&format!("üìù {}\n", overview));
        }
        return Ok(result);
    }
}

/*fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Print search results for "Inception"
    let film_info = search_film("Inception")?;
    println!("{}", film_info);
    
    Ok(())
}*/


// Export a C-compatible function that can be called via libloading
#[unsafe(no_mangle)]
pub extern "C" fn name() -> *mut c_char {

    let metadata = TMDBMetadata;
    let name = metadata.name();
    
    CString::new(name).unwrap().into_raw()
}

// Export a C-compatible function that can be called via libloading
#[unsafe(no_mangle)]
pub extern "C" fn version() -> *mut c_char {

    let metadata = TMDBMetadata;
    let version = metadata.version();
    
    CString::new(version).unwrap().into_raw()
}

// Export a C-compatible function that can be called via libloading
#[unsafe(no_mangle)]
pub extern "C" fn plugin_type() -> *mut c_char {

    let metadata = TMDBMetadata;
    let plugin_type = metadata.plugin_type();
    
   CString::new(plugin_type).unwrap().into_raw()
}

// Export a C-compatible function that can be called via libloading
#[unsafe(no_mangle)]
pub extern "C" fn metadata(name_ptr: *const c_char) -> *mut c_char {
    // Safety: We assume the caller passes a valid C string
    let film_name = unsafe {
        if name_ptr.is_null() {
            "invalid name"
        } else {
            CStr::from_ptr(name_ptr).to_str().unwrap_or("invalid name")
        }
    };
    
    let metadata = TMDBMetadata;
    let result = metadata.metadata(film_name);
    
    // Convert result to C string
    CString::new(result).unwrap().into_raw()
}

// Helper function to free strings allocated by the plugin
#[unsafe(no_mangle)]
pub extern "C" fn free_string(s: *mut c_char) {
    unsafe {
        if !s.is_null() {
            let _ = CString::from_raw(s);
        }
    }
}

/*#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Print search results for "Inception"
    let film_info = search_film("Inception").await?;
    println!("{}", film_info);
    
    Ok(())
}*/