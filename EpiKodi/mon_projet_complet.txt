
==========================================
Ì≥Ñ FICHIER : ./Cargo.toml
==========================================
[package]
name = "EpiKodi"
version = "0.1.0"
edition = "2021" # üëà C'EST LA CL√â ! (2024 n'existe pas encore stable)

[dependencies]
# On garde Dioxus simple et robuste
dioxus = { version = "0.5", features = ["desktop", "router", "hooks"] }
dioxus-desktop = "0.5"

# Tes autres libs
plugin-api = { path = "../plugin_api" } 
libloading = "0.8"
rodio = "0.21.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
lofty = "0.22.4"
rusqlite = { version = "0.31", features = ["bundled"] }
tokio = { version = "1", features = ["full"] }
base64 = "0.21"
warp = "0.3"
rfd = "0.14"
directories = "5.0"
once_cell = "1.18"
dirs = "5.0"
reqwest = { version = "0.11", features = ["blocking"] }
chrono = "0.4.43"

==========================================
Ì≥Ñ FICHIER : ./src/config.rs
==========================================
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;
// On enl√®ve "directories" pour simplifier au max

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AppConfig {
    pub media_path: String,
}

impl AppConfig {
    pub fn load() -> Self {
        let config_path = PathBuf::from("config.json"); // <--- Juste ici, √† la racine !
        
        // Si le fichier existe, on le charge
        if config_path.exists() {
            if let Ok(content) = fs::read_to_string(&config_path) {
                if let Ok(config) = serde_json::from_str(&content) {
                    return config;
                }
            }
        }

        // Sinon, on prend le dossier courant par d√©faut
        let default_path = std::env::current_dir()
            .unwrap_or(PathBuf::from("."))
            .to_string_lossy()
            .to_string();

        let new_config = AppConfig { media_path: default_path };
        new_config.save(); // On le cr√©e tout de suite !
        new_config
    }

    pub fn save(&self) {
        let config_path = PathBuf::from("config.json");
        let json = serde_json::to_string_pretty(self).unwrap();
        let _ = fs::write(config_path, json);
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/constants/constants.rs
==========================================

/*
This file contains constant values used throughout the application
TODO: check the if there is a correct way to do that and good practices
*/

pub const DEBUG: bool = true;

pub const SOURCE_FILE: &str = "db/sources.json";
pub const MEDIA_DB_FILE: &str = "db/library.db";
pub const LOG_FILE: &str = "epikodi.log";

pub const AUDIO_EXTS: [&str; 5] = ["mp3", "wav", "flac", "ogg", "mp4"];
pub const VIDEO_EXTS: [&str; 4] = ["mp4", "mkv", "avi", "mov"];
pub const IMAGE_EXTS: [&str; 4] = ["jpg", "png", "bmp", "gif"];

pub const PLUGIN_DIR: &str = "./plugins/";
pub const PLUGIN_EXT: &str = if cfg!(target_os = "windows") {
    "dll"
} else if cfg!(target_os = "macos") {
    "dylib"
} else {
    "so"
};

// Media status constants
pub const NOT_STARTED: i32 = 0;
pub const PLAYING: i32 = 1;
pub const FINISHED: i32 = 2;
==========================================
Ì≥Ñ FICHIER : ./src/constants/mod.rs
==========================================
#![allow(non_snake_case)]

pub mod constants;
pub use constants::*;
==========================================
Ì≥Ñ FICHIER : ./src/database/db.rs
==========================================
/*

*/

use rusqlite::{Connection, Result};

use crate::library::media_library::ScannedMedia;
use crate::media::data::MediaType;

#[derive(Debug)]
pub struct MediaRow {
    pub id: i64,
    pub path: String,
    pub title: Option<String>,
    pub duration: Option<f32>,
    pub media_type: MediaType,
}

pub struct DB {
    pub conn: Connection,
    pub media_rows: Vec<MediaRow>,
}


impl DB {
    pub fn new() -> Self {
        DB {
            conn: Connection::open("db/library.db").unwrap(),
            media_rows: Vec::new(),
        }
    }

    pub fn clear_all_media(&self) -> Result<(), rusqlite::Error> {
        self.conn.execute("DELETE FROM media", [])?;
        println!("üóëÔ∏è BASE DE DONN√âES VID√âE");
        Ok(())
    }

    //TODO: check if this is a corrct/clean way to do this
    pub fn init_db(&mut self) -> Result<()> {
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS media (
                    id INTEGER PRIMARY KEY,
                    path TEXT UNIQUE NOT NULL,
                    title TEXT,
                    duration REAL,
                    media_type TEXT,
                    status INTEGER DEFAULT 0,
                    time_stop FLOAT DEFAULT 0.0
                )
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS tags (
                    id INTEGER PRIMARY KEY,
                    name TEXT UNIQUE NOT NULL
                );
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS media_tags (
                    media_id INTEGER NOT NULL,
                    tag_id INTEGER NOT NULL,
                    PRIMARY KEY (media_id, tag_id),
                    FOREIGN KEY (media_id) REFERENCES media(id) ON DELETE CASCADE,
                    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
                );
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS playlists (
                    id INTEGER PRIMARY KEY,
                    name TEXT NOT NULL UNIQUE COLLATE NOCASE
                );
            ",
            [],
        )?;
        self.conn.execute(
            "
                CREATE TABLE IF NOT EXISTS playlist_items (
                    playlist_id INTEGER NOT NULL,
                    media_id INTEGER NOT NULL,
                    PRIMARY KEY (playlist_id, media_id),
                    FOREIGN KEY (playlist_id) REFERENCES playlists(id) ON DELETE CASCADE,
                    FOREIGN KEY (media_id) REFERENCES media(id) ON DELETE CASCADE
                );
            ",
            [],
        )?;
        Ok(())
    }

    //status : 0 = not started, 1 = playing, 2 = finished
    pub fn update_media_status_and_time(&mut self, media_id: i64, status: i32, time_stop: f64) -> Result<()> {
        self.conn.execute(
            "
                UPDATE media
                SET status = ?1, time_stop = ?2
                WHERE id = ?3
            ",
            (status, time_stop, media_id),
        )?;
        Ok(())
    }
    //========MEDIA TABLE METHODS========

    pub fn insert_media(&mut self, path: &str, title: &str, duration: f32, media_type: &str) -> Result<()> {
        self.conn.execute(
            "
                INSERT OR IGNORE INTO media (path, title, duration, media_type)
                VALUES (?1, ?2, ?3, ?4)
            ",
            (path, title, duration, media_type),
        )?;
        Ok(())
    }

    pub fn get_all_media(&mut self) -> Result<&Vec<MediaRow>> {

        let mut stmt = self.conn.prepare(
            "SELECT id, path, title, duration, media_type FROM media"
        )?;

        let rows = stmt.query_map([], |row| {
            Ok(MediaRow {
                id: row.get(0)?,
                path: row.get(1)?,
                title: row.get(2)?,
                duration: row.get(3)?,
                media_type: MediaType::from_db(&row.get::<_, String>(4)?).unwrap(),
            })
        })?;

        for r in rows {
           self.media_rows.push(r?);
        }
        Ok(&self.media_rows)
    }


    pub fn print_media_rows(&mut self) {
        println!("{:#?}", self.media_rows);
    }

    pub fn upsert_media(&mut self, media: &ScannedMedia) -> rusqlite::Result<()> {
        self.conn.execute(
            "
            INSERT INTO media (path, title, duration, media_type)
            VALUES (?1, ?2, ?3, ?4)
            ON CONFLICT(path) DO UPDATE SET
                title = excluded.title,
                duration = excluded.duration,
                media_type = excluded.media_type
            ",
            (
                &media.path,
                &media.name,
                media.duration,
                &media.media_type.to_string(),
            ),
        )?;
        Ok(())
    }

    pub fn upsert_media_from_scan(&mut self, scanned_media: Vec<ScannedMedia>) -> rusqlite::Result<()> {
        let tx = self.conn.transaction()?;
        {
            let mut stmt = tx.prepare(
                "
                INSERT INTO media (path, title, duration, media_type)
                VALUES (?1, ?2, ?3, ?4)
                ON CONFLICT(path) DO UPDATE SET
                    title = excluded.title,
                    duration = excluded.duration,
                    media_type = excluded.media_type
                ",
            )?;

            for media in scanned_media {
                stmt.execute((
                    &media.path,
                    &media.name,
                    media.duration,
                    &media.media_type.to_string(),
                ))?;
            }
        }
        tx.commit()?;
        Ok(())
    }

    pub fn cleanup_missing_media(&mut self, scanned_media: Vec<ScannedMedia>) -> rusqlite::Result<()> {

        let scanned_paths: Vec<String> = scanned_media.iter().map(|m| m.path.clone()).collect();
        let placeholders = scanned_paths.iter().map(|_| "?").collect::<Vec<_>>().join(", ");
        let sql = format!("DELETE FROM media WHERE path NOT IN ({})", placeholders);

        let mut stmt = self.conn.prepare(&sql)?;
        let params: Vec<&dyn rusqlite::ToSql> = scanned_paths.iter().map(|p| p as &dyn rusqlite::ToSql).collect();
        stmt.execute(rusqlite::params_from_iter(params))?;
        Ok(())
    }

    //========= TAGS TABLE METHODS========

    pub fn get_or_create_tag(&mut self, name: &str) -> rusqlite::Result<i64> {
        self.conn.execute(
            "INSERT OR IGNORE INTO tags (name) VALUES (?1)",
            [name],
        )?;

        self.conn.query_row(
            "SELECT id FROM tags WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }

    //TODO: y a pas de gestion d'erreur ici c'est important √† corriger
    pub fn get_tag_id(&mut self, name: &str) -> rusqlite::Result<i64> {
        self.conn.query_row(
            "SELECT id FROM tags WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }


    pub fn add_tag_to_media(&mut self, media_id: i64, tag_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
                INSERT OR IGNORE INTO media_tags (media_id, tag_id)
                VALUES (?1, ?2)
            ",
            (media_id, tag_id),
        )?;
        Ok(())
    }


    pub fn get_media_by_tag(&mut self, tag_name: &str) -> rusqlite::Result<Vec<i64>> {
        let mut stmt = self.conn.prepare(
            "
                SELECT media.id
                FROM media
                JOIN media_tags ON media.id = media_tags.media_id
                JOIN tags ON tags.id = media_tags.tag_id
                WHERE tags.name = ?1
            ",
        )?;

        let rows = stmt.query_map([tag_name], |row| row.get(0))?;

        Ok(rows.filter_map(Result::ok).collect())
    }

    //========= PLAYLIST TABLE METHODS========


    pub fn create_playlist(&mut self, name: &str) -> rusqlite::Result<i64> {

        self.conn.execute(
            "INSERT OR IGNORE INTO playlists (name) VALUES (?1)",
            [name],
        )?;

        self.conn.query_row(
            "SELECT id FROM playlists WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }

    pub fn delete_playlist(&mut self, playlist_id: i64) -> rusqlite::Result<()> {

        self.conn.execute(
            "DELETE FROM playlist_items WHERE playlist_id = ?1",
            [playlist_id],
        )?;
        self.conn.execute(
            "DELETE FROM playlists WHERE id = ?1",
            [playlist_id],
        )?;
        Ok(())
    }

    pub fn add_media_to_playlist(&mut self, media_id: i64, playlist_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
            INSERT OR REPLACE INTO playlist_items
            (playlist_id, media_id)
            VALUES (?1, ?2)
            ",
            (playlist_id, media_id),
        )?;
        Ok(())
    }

    pub fn remove_media_from_playlist(&mut self, media_id: i64, playlist_id: i64) -> rusqlite::Result<()> {
        self.conn.execute(
            "
            DELETE FROM playlist_items
            WHERE playlist_id = ?1 AND media_id = ?2
            ",
            (playlist_id, media_id),
        )?;
        Ok(())
    }

    pub fn get_media_from_playlist(&mut self, playlist_id: i64) -> rusqlite::Result<Vec<i64>> {
        let mut stmt = self.conn.prepare(
            "
                SELECT media_id
                FROM playlist_items
                WHERE playlist_id = ?1
                ORDER BY position ASC
            ",
        )?;

        let rows = stmt.query_map([playlist_id], |row| row.get(0))?;

        Ok(rows.filter_map(Result::ok).collect())
    }
    
    //ORDER BY position ASC
    pub fn get_playlist_id(&mut self, name: &str) -> rusqlite::Result<i64> {
        self.conn.query_row(
            "SELECT id FROM playlists WHERE name = ?1",
            [name],
            |row| row.get(0),
        )
    }

    pub fn get_all_playlists(&mut self) -> rusqlite::Result<Vec<(i64, String)>> {
        let mut stmt = self.conn.prepare(
            "
                SELECT id, name
                FROM playlists
                ORDER BY name COLLATE NOCASE ASC
            ",
        )?;

        let rows = stmt.query_map([], |row| {
            Ok((row.get(0)?, row.get(1)?))
        })?;

        Ok(rows.filter_map(Result::ok).collect())
    }









    //========TESTING PURPOSES ONLY========

    pub fn clear_media_table(&mut self) -> Result<()> {
        self.conn.execute(
            "DELETE FROM media",
            [],
        )?;
        Ok(())
    }

    pub fn add_sample_data(&mut self) -> Result<()> {
        self.insert_media("path/to/media1.mp4", "Sample Media 1", 300.0, "video")?;
        self.insert_media("path/to/media2.mp3", "Sample Media 2", 200.0, "audio")?;
        self.insert_media("path/to/media3.jpg", "Sample Media 3", 0.0, "image")?;
        Ok(())
    }

    

} 












#[cfg(test)]
mod tests {
    use super::*;
    use rusqlite::Connection;

    fn create_test_db() -> DB {
        let conn = Connection::open_in_memory().unwrap();
        let mut db = DB {
            conn,
            media_rows: Vec::new(),
        };
        db.init_db().unwrap();
        db
    }

    #[test]
    fn test_init_db() {
        let mut db = create_test_db();

        assert!(db.init_db().is_ok());
    }

    #[test]
    fn test_insert_media() {
        let mut db = create_test_db();

        assert!(db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").is_ok());
    }

    #[test]
    fn test_get_all_media() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        
        let media = db.get_all_media().unwrap();

        assert_eq!(media.len(), 1);
        assert_eq!(media[0].path, "path/to/video.mp4");
    }

    #[test]
    fn test_get_or_create_tag() {
        let mut db = create_test_db();
        let tag_id1 = db.get_or_create_tag("action").unwrap();
        let tag_id2 = db.get_or_create_tag("action").unwrap();

        assert_eq!(tag_id1, tag_id2);
    }

    #[test]
    fn test_get_tag_id() {
        let mut db = create_test_db();
        db.get_or_create_tag("comedy").unwrap();

        let tag_id = db.get_tag_id("comedy").unwrap();

        assert!(tag_id > 0);
    }

    #[test]
    fn test_add_tag_to_media() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        
        let tag_id = db.get_or_create_tag("action").unwrap();
        
        assert!(db.add_tag_to_media(1, tag_id).is_ok());
    }

    #[test]
    fn test_get_media_by_tag() {
        let mut db = create_test_db();
        db.insert_media("path/to/video1.mp4", "Video 1", 120.0, "video").unwrap();
        db.insert_media("path/to/video2.mp4", "Video 2", 150.0, "video").unwrap();
        
        let tag_id = db.get_or_create_tag("action").unwrap();
        db.add_tag_to_media(1, tag_id).unwrap();
        
        let media = db.get_media_by_tag("action").unwrap();
        
        assert_eq!(media.len(), 1);
        assert_eq!(media[0], 1);
    }

    #[test]
    fn test_create_playlist() {
        let mut db = create_test_db();
        let playlist_id = db.create_playlist("My Playlist").unwrap();
        
        assert!(playlist_id > 0);
    }

    #[test]
    fn test_add_media_to_playlist() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        let playlist_id = db.create_playlist("My Playlist").unwrap();
        
        assert!(db.add_media_to_playlist(1, playlist_id).is_ok());
    }

    #[test]
    #[ignore]
    fn test_get_media_from_playlist() {
        let mut db = create_test_db();
        db.insert_media("path/to/video1.mp4", "Video 1", 120.0, "video").unwrap();
        db.insert_media("path/to/video2.mp4", "Video 2", 150.0, "video").unwrap();
        
        let playlist_id = db.create_playlist("My Playlist").unwrap();
        db.add_media_to_playlist(1, playlist_id).unwrap();
        db.add_media_to_playlist(2, playlist_id).unwrap();
        
        let media = db.get_media_from_playlist(playlist_id).unwrap();
        
        assert_eq!(media.len(), 2);
    }

    #[test]
    fn test_get_playlist_id() {
        let mut db = create_test_db();
        db.create_playlist("Test Playlist").unwrap();
        let id = db.get_playlist_id("Test Playlist").unwrap();

        assert!(id > 0);
    }

    #[test]
    fn test_clear_media_table() {
        let mut db = create_test_db();
        db.insert_media("path/to/video.mp4", "Test Video", 120.5, "video").unwrap();
        
        assert!(db.clear_media_table().is_ok());
        let media = db.get_all_media().unwrap();
        
        assert_eq!(media.len(), 0);
    }
}



==========================================
Ì≥Ñ FICHIER : ./src/database/mod.rs
==========================================
pub mod db; 
==========================================
Ì≥Ñ FICHIER : ./src/gui/init.rs
==========================================
use dioxus::prelude::*;
use dioxus_router::prelude::*;

use std::sync::{mpsc, OnceLock};
use tokio::sync::broadcast;

use crate::threading::media_thread::launch_media_thread;
use crate::threading::command::{Command, Event};

use crate::media::data::{MediaInfo, MediaType};
use crate::gui::pages::PluginSearchResult;
use crate::gui::route::Route;

use crate::config::AppConfig;
use std::cell::RefCell;
use std::rc::Rc;
use std::path::PathBuf;
use std::time::Duration;
use std::collections::HashMap;
use crate::iptv::parser::TVChannel;


pub static RELOAD_SIGNAL: OnceLock<broadcast::Sender<()>> = OnceLock::new();

struct Backend {
    tx: mpsc::Sender<Command>,
    rx: RefCell<Option<mpsc::Receiver<Event>>>,
}

// === COMPOSANT RACINE (D√âPLAC√â) ===
pub fn App() -> Element {
    let backend_channels = use_hook(|| {
        let (cmd_tx, cmd_rx) = mpsc::channel::<Command>();
        let (evt_tx, evt_rx) = mpsc::channel::<Event>();
        
        launch_media_thread(cmd_rx, evt_tx);

        let config = AppConfig::load();
        let root_path = PathBuf::from(config.media_path);
        
        // Initialisation scan
        let _ = cmd_tx.send(Command::AddSource(root_path.clone(), MediaType::Video));
        let _ = cmd_tx.send(Command::AddSource(root_path.clone(), MediaType::Audio));
        let _ = cmd_tx.send(Command::AddSource(root_path, MediaType::Image));
        let _ = cmd_tx.send(Command::GetAllMedia());

        Rc::new(Backend { tx: cmd_tx, rx: RefCell::new(Some(evt_rx)) })
    });

    use_context_provider(|| backend_channels.tx.clone());
    
    // √âtats globaux
    let mut media_list = use_context_provider(|| Signal::new(Vec::<MediaInfo>::new()));
    
    // Plugin Result
    let mut plugin_result = use_context_provider(|| Signal::new(PluginSearchResult { 
        text: String::from("En attente d'une recherche...") 
    }));
    
    let mut root_path_signal = use_context_provider(|| Signal::new(String::new()));
    let current_config = AppConfig::load();
    root_path_signal.set(current_config.media_path);

    if let Some(tx) = RELOAD_SIGNAL.get() {
        use_context_provider(|| tx.clone());
    }

    let mut iptv_loading = use_context_provider(|| Signal::new(false)); 
    let mut iptv_channels = use_context_provider(|| Signal::new(Vec::<TVChannel>::new()));

    // BOUCLE D'√âV√âNEMENTS
    use_coroutine(|_: UnboundedReceiver<()>| {
        let backend = backend_channels.clone();
        async move {
            let mut rx_opt = backend.rx.borrow_mut();
            if let Some(rx) = rx_opt.take() {
                drop(rx_opt);
                loop {
                    while let Ok(msg) = rx.try_recv() {
                        match msg {
                            Event::MediaList(list) => { media_list.set(list); },
                            
                            // üëá Ta gestion MusicBrainz (adapt√©e √† 2 arguments path+info)
                            Event::ArtistInfoReceived(info) => {
                                plugin_result.set(PluginSearchResult { text: info });
                            },

                            Event::NowPlaying(id) => println!("‚ñ∂Ô∏è Lecture ID: {}", id),
                            Event::Info(info) => println!("‚ÑπÔ∏è Info: {:?}", info.title),
                            Event::M3UList(channels) => {
                                println!("üì∫ UI : Re√ßu {} cha√Ænes !", channels.len());
                                iptv_channels.set(channels);
                                iptv_loading.set(false);
                            },
                            _ => {} 
                        }
                    }
                    tokio::time::sleep(Duration::from_millis(50)).await;
                }
            }
        }
    });

    rsx! { Router::<Route> {} }
}
==========================================
Ì≥Ñ FICHIER : ./src/gui/layout.rs
==========================================
use dioxus::prelude::*;
use dioxus_router::prelude::*;
use super::route::Route;       // On a besoin de conna√Ætre les routes pour les liens
use super::style::GLOBAL_STYLE; // On importe le style

pub fn AppLayout() -> Element {
    rsx! {
        style { "{GLOBAL_STYLE}" }
        div { class: "container",
            // -------- MENU LATERAL --------
            nav { class: "sidebar",
                Link { to: Route::Home {}, class: "nav-item", "Accueil" }
                Link { to: Route::Iptv {}, class: "nav-item", "Iptv" }
                Link { to: Route::Videos {}, class: "nav-item", "Vid√©os" }
                Link { to: Route::Series {}, class: "nav-item", "S√©ries" }
                Link { to: Route::Music {}, class: "nav-item", "Musique" }
                Link { to: Route::Images {}, class: "nav-item", "Images" }
                Link { to: Route::Plugins {}, class: "nav-item", "Add-ons" }
                Link { to: Route::Settings {}, class: "nav-item", "Param√®tres" }
            }

            // -------- ZONE CONTENU DYNAMIQUE --------
            main { class: "content",
                Outlet::<Route> {}
            }
        }
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/gui/mod.rs
==========================================
pub mod route;
pub mod layout;
pub mod pages;
pub mod style;
pub mod init;
==========================================
Ì≥Ñ FICHIER : ./src/gui/pages.rs
==========================================
use dioxus::prelude::*;
use super::route::Route;
use crate::threading::command::Command;
use crate::media::data::{MediaType, MediaInfo};
use crate::config::AppConfig;
use std::fs; 
use base64::{Engine as _, engine::general_purpose};
use std::path::{Path, PathBuf};
use tokio::sync::broadcast;
// üëá IMPORT NECESSAIRE POUR LA TV (Tri et Structures)
use crate::iptv::parser::{TVChannel, ContentType};

// üëá STRUCTURE POUR LES PLUGINS
#[derive(Clone, PartialEq)]
pub struct PluginSearchResult {
    pub text: String,
}

// --- FONCTION UTILITAIRE URL ---
fn make_url(full_path: &str, root_path: &str) -> String {
    let path_obj = Path::new(full_path);
    let root_obj = Path::new(root_path);

    match path_obj.strip_prefix(root_obj) {
        Ok(relative) => {
            let relative_str = relative.to_string_lossy().replace("\\", "/");
            let clean_url = relative_str.replace(" ", "%20").replace("#", "%23");
            format!("http://127.0.0.1:3030/media/{}", clean_url)
        },
        Err(_) => {
            format!("http://127.0.0.1:3030/media/{}", full_path.replace("\\", "/").replace(" ", "%20"))
        }
    }
}

// --- ACCUEIL ---
#[component]
pub fn Home() -> Element {
    rsx! {
        div { class: "container",
            div { style: "display: flex; flex-direction: column; align-items: center; justify-content: center; padding-top: 50px;",
                h1 { style: "font-size: 4rem; margin-bottom: 50px; color: #007acc; text-transform: uppercase; letter-spacing: 5px;", "NeoKodi" }
                
                div { class: "media-grid", style: "width: 100%; max-width: 900px;",
                    Link { to: Route::Videos {}, class: "media-card", div { class: "card-icon", "üé¨" } div { class: "card-text", "Vid√©os" } }
                    Link { to: Route::Images {}, class: "media-card", div { class: "card-icon", "üñºÔ∏è" } div { class: "card-text", "Images" } }
                    Link { to: Route::Music {}, class: "media-card", div { class: "card-icon", "üéµ" } div { class: "card-text", "Musique" } }
                    Link { to: Route::Plugins {}, class: "media-card", div { class: "card-icon", "üß©" } div { class: "card-text", "Plugins" } }
                    Link { to: Route::Settings {}, class: "media-card", div { class: "card-icon", "‚öôÔ∏è" } div { class: "card-text", "Param√®tres" } }
                }
            }
        }
    }
}

// --- MUSIQUE ---
#[component]
pub fn Music() -> Element {
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let list_signal = use_context::<Signal<Vec<MediaInfo>>>();
    let root_path_signal = use_context::<Signal<String>>();
    let root_path = root_path_signal();
    let plugin_result = use_context::<Signal<PluginSearchResult>>();
    
    let mut current_audio = use_signal(|| Option::<String>::None);
    let tx_init = cmd_tx.clone();
    
    use_hook(move || { if list_signal().is_empty() { tx_init.send(Command::GetAllMedia()).unwrap(); } });

    rsx! {
        div { class: "container",
            if let Some(path) = current_audio() {
                div { style: "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #121212; z-index: 999; display: flex; flex-direction: column;",
                    div { style: "flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;",
                        div { style: "font-size: 5rem; margin-bottom: 20px;", "üéµ" }
                        h2 { "Lecture en cours" }
                        audio { controls: true, autoplay: true, style: "width: 80%; max-width: 600px;",
                            onended: move |_| current_audio.set(None),
                            src: "{make_url(&path, &root_path)}"
                        }
                        button { 
                            class: "btn-nav", 
                            style: "position: relative; transform: none; top: auto; left: auto; background-color: #d32f2f; border-color: #b71c1c; font-size: 1.2rem; padding: 15px 40px;", 
                            onclick: move |_| current_audio.set(None), 
                            "‚èπÔ∏è Arr√™ter la lecture" 
                        }
                        div { 
                            style: "color: #4caf50; font-size: 1.5rem; font-weight: bold; text-align: center; max-width: 600px; padding: 10px; border: 1px dashed #333; border-radius: 8px;",
                            "{plugin_result.read().text}" 
                        }
                    }
                }
            } else {
                div { class: "top-bar", 
                    Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, 
                    div { class: "page-title", "Musique" } 
                }
                div { class: "audio-list",
                    for item in list_signal().iter().filter(|i| i.media_type == MediaType::Audio) {
                        div { class: "audio-row",
                            onclick: { 
                                let p = item.path.clone(); 
                                let i = item.id; 
                                let tx = cmd_tx.clone();
                                
                                let mut res = plugin_result.clone(); 

                                move |_| { 
                                    res.set(PluginSearchResult { text: String::from("üîé Recherche MusicBrainz en cours...") });

                                    current_audio.set(Some(p.clone())); 
                                    
                                    tx.send(Command::Play(i)).unwrap(); 
                                    
                                    tx.send(Command::GetArtistMetadataFromPlugin(p.clone())).unwrap();
                                } 
                            },
                            div { class: "audio-icon", "üéµ" }
                            div { class: "audio-info", div { class: "audio-title", "{item.title.as_deref().unwrap_or(&item.path)}" } div { class: "audio-artist", "Artiste inconnu" } }
                        }
                    }
                }
            }
        }
    }
}

// --- FILMS (VIDEOS) ---
#[component]
pub fn Videos() -> Element {
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let list_signal = use_context::<Signal<Vec<MediaInfo>>>();
    let root_path_signal = use_context::<Signal<String>>();
    let root_path = root_path_signal();
    
    let mut current_video = use_signal(|| Option::<String>::None);
    let tx_init = cmd_tx.clone(); 
    use_hook(move || { if list_signal().is_empty() { tx_init.send(Command::GetAllMedia()).unwrap(); } });

    rsx! {
        div { class: "container",
            if let Some(path) = current_video() {
                div { style: "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 999; display: flex; flex-direction: column;",
                    div { style: "height: 60px; padding: 10px;",
                        button { class: "btn-nav", style: "position: relative; top: 0; left: 0; transform: none;", onclick: move |_| current_video.set(None), "‚¨Ö Retour" }
                    }
                    div { style: "flex: 1; min-height: 0; display: flex; align-items: center; justify-content: center;",
                        {
                            let url = make_url(&path, &root_path);
                            rsx! { video { key: "{url}", src: "{url}", controls: true, autoplay: true, style: "max-width: 100%; max-height: 100%; width: 100%;" } }
                        }
                    }
                }
            } else {
                div { class: "top-bar", 
                    Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, 
                    div { class: "page-title", "Vid√©os" } 
                }
                div { class: "media-grid",
                    for item in list_signal().iter().filter(|i| i.media_type == MediaType::Video) {
                        div { class: "media-card",
                            onclick: { let p=item.path.clone(); let i=item.id; let tx=cmd_tx.clone(); move |_| { current_video.set(Some(p.clone())); tx.send(Command::Play(i)).unwrap(); } },
                            div { class: "card-icon", "üé¨" }
                            div { class: "card-text", style: "overflow: hidden; text-overflow: ellipsis; white-space: nowrap; width: 100%;", "{item.title.as_deref().unwrap_or(&item.path)}" }
                        }
                    }
                }
            }
        }
    }
}

// --- IMAGES ---
#[component]
pub fn Images() -> Element {
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let list_signal = use_context::<Signal<Vec<MediaInfo>>>();
    let mut current_image = use_signal(|| Option::<String>::None);
    let tx_init = cmd_tx.clone();
    use_hook(move || { if list_signal().is_empty() { tx_init.send(Command::GetAllMedia()).unwrap(); } });

    rsx! {
        div { class: "container",
            if let Some(data) = current_image() {
                div { style: "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 999; display: flex; flex-direction: column;",
                    div { style: "height: 60px; padding: 10px;",
                        button { class: "btn-nav", style: "position: relative; top: 0; left: 0; transform: none;", onclick: move |_| current_image.set(None), "Fermer" }
                    }
                    div { style: "flex: 1; min-height: 0; display: flex; align-items: center; justify-content: center;",
                         img { src: "{data}", style: "max-width: 100%; max-height: 100%; object-fit: contain;" }
                    }
                }
            } else {
                div { class: "top-bar", 
                    Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, 
                    div { class: "page-title", "Images" } 
                }
                div { class: "media-grid",
                    for item in list_signal().iter().filter(|i| i.media_type == MediaType::Image) {
                        div { class: "media-card",
                            onclick: {
                                let p=item.path.clone(); let i=item.id; let tx=cmd_tx.clone();
                                move |_| { 
                                    if let Ok(bytes) = fs::read(&p) {
                                        let b64 = general_purpose::STANDARD.encode(&bytes);
                                        current_image.set(Some(format!("data:image/png;base64,{}", b64)));
                                    }
                                    tx.send(Command::Play(i)).unwrap();
                                }
                            },
                            div { class: "card-icon", "üñºÔ∏è" }
                            div { class: "card-text", style: "overflow: hidden; text-overflow: ellipsis; white-space: nowrap; width: 100%;", "{item.title.as_deref().unwrap_or(&item.path)}" }
                        }
                    }
                }
            }
        }
    }
}

// --- PLUGINS (ADDONS) ---
#[component] 
pub fn Plugins() -> Element { 
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let plugin_result = use_context::<Signal<PluginSearchResult>>();
    let mut search_text = use_signal(|| String::from("Nirvana"));

    rsx! { 
        div { class: "container", 
            div { class: "top-bar", 
                Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, 
                div { class: "page-title", "Add-ons" } 
            }
            
            div { style: "display: flex; flex-direction: column; align-items: center; gap: 30px; margin-top: 50px;",
                h2 { "Test Plugin MusicBrainz" }

                div { style: "display: flex; gap: 10px;",
                    input {
                        style: "padding: 10px; border-radius: 4px; border: 1px solid #333; background: #1e1e1e; color: white; width: 300px;",
                        value: "{search_text}",
                        oninput: move |evt| search_text.set(evt.value())
                    }
                    button { 
                        class: "btn-nav", 
                        style: "position: relative; transform: none; top: auto; left: auto;",
                        onclick: move |_| {
                            cmd_tx.send(Command::GetArtistMetadataFromPlugin(search_text())).unwrap();
                        },
                        "üîç Rechercher"
                    }
                }

                div { style: "background: #1e1e1e; padding: 20px; border-radius: 8px; border: 1px solid #333; max-width: 600px; width: 80%; min-height: 100px;",
                    h3 { style: "margin-top: 0; color: #aaa; font-size: 1rem;", "R√©sultat du plugin :" }
                    pre { style: "color: #007acc; white-space: pre-wrap; font-family: monospace; font-size: 1.1rem;",
                        "{plugin_result().text}"
                    }
                }
            }
        } 
    } 
}

// --- AUTRES PAGES ---
#[component] pub fn Iptv() -> Element { rsx! { div { class: "container", div { class: "top-bar", Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, div { class: "page-title", "S√©ries" } } } } }
#[component] pub fn Series() -> Element { rsx! { div { class: "container", div { class: "top-bar", Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, div { class: "page-title", "S√©ries" } } } } }
#[component] pub fn PageNotFound(route: Vec<String>) -> Element { rsx! { div { class: "container", h1 { "404 - Page non trouv√©e" }, Link { to: Route::Home {}, class: "btn-nav", "Retour Accueil" } } } }

// --- PARAM√àTRES ---
#[component] 
pub fn Settings() -> Element { 
    let mut root_path_signal = use_context::<Signal<String>>();
    let cmd_tx = use_context::<std::sync::mpsc::Sender<Command>>();
    let reload_tx = use_context::<broadcast::Sender<()>>();

    rsx! { 
        div { class: "container", 
            div { class: "top-bar", 
                Link { to: Route::Home {}, class: "btn-nav", "üè† Accueil" }, 
                div { class: "page-title", "Param√®tres" } 
            }
            div { style: "display: flex; flex-direction: column; align-items: center; gap: 30px; margin-top: 50px;",
                div { style: "text-align: center;",
                    h2 { "Dossier M√©dia Actuel" }
                    div { style: "background: #1e1e1e; padding: 20px; border-radius: 8px; font-family: monospace; color: #007acc; border: 1px solid #333; margin-top: 10px;",
                        "{root_path_signal}"
                    }
                }
                button { 
                    class: "btn-nav", 
                    style: "position: relative; transform: none; top: auto; left: auto; font-size: 1.2rem; padding: 15px 30px;",
                    onclick: move |_| {
                        if let Some(path) = rfd::FileDialog::new().pick_folder() {
                            let path_str = path.to_string_lossy().to_string();
                            let mut config = AppConfig::load();
                            config.media_path = path_str.clone();
                            config.save();
                            root_path_signal.set(path_str.clone());
                            let p = PathBuf::from(path_str);
                            let _ = cmd_tx.send(Command::ChangeLibraryPath(p));
                            println!("‚ö° SIGNAL DE RED√âMARRAGE SERVEUR ENVOY√â !");
                            let _ = reload_tx.send(()); 
                        }
                    },
                    "üìÇ Changer le dossier racine"
                }
            }
        } 
    } 
}
==========================================
Ì≥Ñ FICHIER : ./src/gui/route.rs
==========================================
use dioxus::prelude::*;
use dioxus_router::prelude::*;
use super::pages::*;

#[derive(Routable, Clone)]
#[rustfmt::skip]
pub enum Route {
    #[route("/")]
    Home {},

    #[route("/Videos")]
    Videos {},

    #[route("/images")]
    Images {},

    #[route("/music")]
    Music {},

    #[route("/series")]
    Series {},

    #[route("/iptv")]
    Iptv {},

    // üëá VOIL√Ä CELUI QUI MANQUAIT
    #[route("/Plugins")]
    Plugins {},

    #[route("/settings")]
    Settings {},

    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
==========================================
Ì≥Ñ FICHIER : ./src/gui/style.rs
==========================================
pub const GLOBAL_STYLE: &str = r#"
    /* RESET GLOBAL */
    html, body { 
        margin: 0; 
        padding: 0;
        font-family: 'Segoe UI', sans-serif; 
        background-color: #121212; 
        color: white; 
        
        /* üëá ON BLOQUE LE CORPS DE PAGE */
        width: 100vw;
        height: 100vh;
        overflow: hidden; /* C'est le container qui scrollera, pas le body */
    }
    
    * { box-sizing: border-box; }
    a { text-decoration: none; color: inherit; }

    /* CONTENEUR PRINCIPAL */
    .container { 
        display: flex; 
        flex-direction: column;
        
        /* üëá LA CORRECTION EST ICI : 100vh FORCE LA TAILLE DE L'√âCRAN */
        height: 100vh;
        width: 100%;
        
        /* C'est ici qu'on active le scroll */
        overflow-y: auto;
        overflow-x: hidden;
        
        padding: 0; 
    }

    /* --- SCROLLBAR PERSONNALIS√âE (Pour √™tre s√ªr qu'on la voit) --- */
    /* WebKit (Chrome, Edge, WebView2) */
    ::-webkit-scrollbar {
        width: 14px; /* Un peu plus large pour √™tre visible */
    }
    ::-webkit-scrollbar-track {
        background: #0a0a0a; 
        border-left: 1px solid #333;
    }
    ::-webkit-scrollbar-thumb {
        background: #444; 
        border-radius: 7px;
        border: 2px solid #0a0a0a; /* Petit bord pour faire joli */
    }
    ::-webkit-scrollbar-thumb:hover {
        background: #007acc; /* Devient bleu au survol */
    }

    /* --- BARRE DU HAUT (STICKY) --- */
    .top-bar {
        position: sticky; 
        top: 0;
        z-index: 100;
        background-color: #121212; /* Opaque pour cacher le contenu qui passe dessous */
        
        display: flex;
        justify-content: center;
        align-items: center;
        
        padding: 20px;
        margin-bottom: 20px;
        border-bottom: 1px solid #333;
        min-height: 80px;
        flex-shrink: 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.8);
    }

    .page-title {
        font-size: 2rem;
        font-weight: bold;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .btn-nav {
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background-color: #252525;
        color: #aaa;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: bold;
        transition: 0.2s;
        border: 1px solid #333;
        cursor: pointer;
        display: flex; align-items: center; gap: 10px;
        z-index: 10;
    }
    .btn-nav:hover {
        background-color: #007acc;
        color: white;
        border-color: #007acc;
    }

    /* --- CONTENU --- */
    .media-grid, .audio-list {
        padding: 20px; 
        padding-bottom: 100px; /* Grosse marge en bas pour scroller confortablement */
    }

    /* --- GRILLE --- */
    .media-grid { 
        display: grid; 
        /* Responsive intelligent */
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); 
        gap: 25px; 
    }

    .media-card { 
        background: #1e1e1e; 
        border-radius: 12px; 
        padding: 20px;
        display: flex; 
        flex-direction: column;
        align-items: center; 
        justify-content: center; 
        transition: transform 0.2s, background-color 0.2s;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        border: 1px solid #333;
        cursor: pointer;
        min-height: 180px; 
        text-align: center;
    }

    .media-card:hover {
        transform: translateY(-5px);
        background-color: #2d2d2d;
        border-color: #007acc;
    }

    .card-icon { font-size: 3rem; margin-bottom: 15px; }
    .card-text { font-size: 1.1rem; font-weight: 600; }

    /* --- LISTE AUDIO --- */
    .audio-list { display: flex; flex-direction: column; gap: 10px; }
    
    .audio-row {
        display: flex; align-items: center;
        background-color: #1e1e1e; padding: 12px 20px;
        border-radius: 8px; cursor: pointer;
        border: 1px solid transparent; transition: 0.2s;
    }
    .audio-row:hover { background-color: #2d2d2d; border-color: #444; transform: translateX(5px); }
    
    .audio-icon { 
        width: 45px; height: 45px; 
        background: #333; border-radius: 6px; 
        margin-right: 20px; display: flex; align-items: center; justify-content: center; 
        font-size: 1.5rem; 
    }
    .audio-info { flex: 1; }
    .audio-title { font-weight: 600; }
    .audio-artist { font-size: 0.85rem; color: #888; }
    
    .loading-container {
        width: 100%;
        max-width: 500px;
        background-color: #333;
        border-radius: 4px;
        height: 6px;
        overflow: hidden;
        margin-top: 20px;
        position: relative;
    }

    .loading-bar {
        height: 100%;
        background-color: #007acc;
        width: 50%;
        position: absolute;
        animation: loading 1.5s infinite ease-in-out;
        border-radius: 4px;
    }

    @keyframes loading {
        0% { left: -50%; width: 30%; }
        50% { width: 60%; }
        100% { left: 100%; width: 30%; }
    }
"#;
==========================================
Ì≥Ñ FICHIER : ./src/iptv/mod.rs
==========================================
pub mod parser;
==========================================
Ì≥Ñ FICHIER : ./src/iptv/parser.rs
==========================================
// src/iptv/parser.rs

#[derive(Debug, Clone, PartialEq)]
pub enum ContentType {
    Live,
    Movie,
    Series,
}

#[derive(Debug, Clone)]
pub struct TVChannel {
    pub title: String,
    pub url: String,
    pub group: Option<String>,
    pub content_type: ContentType,
}

pub fn parse_m3u(content: &str) -> Vec<TVChannel> {
    let mut channels = Vec::new();
    let mut current_title = String::new();
    let mut current_group = None;

    for line in content.lines() {
        let line = line.trim();

        if line.starts_with("#EXTINF:") {
            // 1. Extraction du Titre
            if let Some(comma_index) = line.rfind(',') {
                current_title = line[comma_index + 1..].trim().to_string();
            }

            // 2. Extraction du Groupe
            if let Some(start) = line.find("group-title=\"") {
                let rest = &line[start + 13..];
                if let Some(end) = rest.find('"') {
                    let group_name = rest[..end].to_string();
                    current_group = Some(group_name);
                }
            }
        } else if !line.starts_with("#") && !line.is_empty() {
            // 3. D√©tection
            let content_type = detect_type(&current_group);

            // LOG DE DEBUG : D√©commenter si tu veux voir ce qui se passe
            // if content_type != ContentType::Live {
            //     println!("üîé Trouv√© {:?} dans le groupe '{:?}' -> {}", content_type, current_group, current_title);
            // }

            channels.push(TVChannel {
                title: current_title.clone(),
                url: line.to_string(),
                group: current_group.clone(),
                content_type,
            });
            
            current_title.clear();
            current_group = None;
        }
    }
    
    channels
}

fn detect_type(group: &Option<String>) -> ContentType {
    match group {
        Some(g) => {
            let g_upper = g.to_uppercase();
            
            // Mots-cl√©s pour S√âRIES (tr√®s large)
            if g_upper.contains("SERIE") || 
               g_upper.contains("S√âRIE") || 
               g_upper.contains("SEASON") || 
               g_upper.contains("SAISON") ||
               g_upper.contains("EPISODE") {
                return ContentType::Series;
            }

            // Mots-cl√©s pour FILMS (tr√®s large)
            if g_upper.contains("MOVIE") || 
               g_upper.contains("FILM") || 
               g_upper.contains("VOD") || 
               g_upper.contains("CINEMA") || 
               g_upper.contains("4K") || // Souvent les films sont tagu√©s 4K
               g_upper.contains("FHD") || 
               g_upper.contains("HEVC") {
                // Attention : Parfois les cha√Ænes live ont aussi FHD, 
                // mais dans les M3U IPTV, VOD est souvent explicite.
                // Si ton M3U m√©lange tout, c'est plus dur.
                
                // Raffinement : Si √ßa contient "VOD", c'est s√ªr que c'est un film/s√©rie
                if g_upper.contains("VOD") {
                     return ContentType::Movie;
                }
                
                // Sinon on tente le coup sur "FILM"
                if g_upper.contains("FILM") || g_upper.contains("MOVIE") {
                    return ContentType::Movie;
                }
            }

            ContentType::Live
        },
        None => ContentType::Live,
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/library/media_library.rs
==========================================
use crate::database::db::DB;


use crate::media::data::Media;
use crate::media::data::MediaType;
use crate::media::audio::Audio;
use crate::media::image::Image;
use crate::media::video::Video;
use crate::media::data::MediaInfo;


use std::fs;
use std::collections::HashMap;
use std::path::Path;

use dioxus::html::p;
use rusqlite::{Connection};

use crate::constants::LOG_FILE;
use crate::scan::scan::Scan;
use std::path::PathBuf;
use std::fs::File;

use crate::logger::logger::Logger;

/* 
    let logger = Logger::new(LOG_FILE);

    // Log some messages
    logger.info("Application started");
    logger.debug("This is a debug message");
    logger.warning("This is a warning message");
    logger.error("This is an error message");
    logger.info("Application finished");

*/

#[derive(Debug, Clone)]
pub struct ScannedMedia {
    pub path: String,
    pub name: String,
    pub duration: f32,
    pub media_type: MediaType,
}
pub struct MediaLibrary {
    pub items: HashMap<i64, Box<dyn Media>>,
    pub scan_lib: Scan,
    pub database: DB,
}

impl MediaLibrary {
    pub fn new() -> Self {

        Self {
            items: HashMap::new(),
            scan_lib: Scan::new(),
            database: DB::new(),
        }
    }

    pub fn init(&mut self) {

        // scan the libraries
        self.database.init_db().unwrap();
        self.scan_lib.scan_libraries();

        // update the database
        self.database.upsert_media_from_scan(self.scan_lib.scan.clone()).unwrap(); //TODO: ce clone me fait chier, il faudrait qu'on utilise juste scan (ca serait meme mieux si on donne la valeur direct comme ca il se fait drop (on en a plus besoin ) et mm en terme de performance c'est pas terrible parce que c'est un gros object )
        self.database.cleanup_missing_media(self.scan_lib.scan.clone()).unwrap(); // TODO to implement, shuld be called every scans
        self.database.get_all_media().unwrap();
        //self.database.print_media_rows();
    
        
        for row in self.database.media_rows.iter() {

            let media: Box<dyn Media> = match row.media_type {
                MediaType::Audio => Box::new(Audio::new(&row.path,&row.title.as_deref().unwrap_or(""))),
                MediaType::Video => Box::new(Video::new(row.id, &row.path, &row.title.as_deref().unwrap_or(""))),
                MediaType::Image => Box::new(Image::new(row.id, &row.path, &row.title.as_deref().unwrap_or(""))), };

            self.items.insert(row.id, media);
        }

    }    

    pub fn reload(&mut self) {
        let logger = Logger::new(LOG_FILE);
        logger.info("üîÑ Reloading media library...");
        self.init();
        logger.info(&format!("‚úÖ Media library reloaded with {} items.", self.items.len()));
    }

    pub fn update_media_status_and_time(&mut self, media_id: i64, status: i32, time_stop: f64) {
        let logger = Logger::new(LOG_FILE);
        
        match self.database.update_media_status_and_time(media_id, status, time_stop) {
            Ok(_) => logger.debug(&format!("Updated media ID {} with status {} and time_stop {}", media_id, status, time_stop)),
            Err(e) => logger.error(&format!("Error updating media ID {}: {}", media_id, e)),
        }
    }

    pub fn create_playlist(&mut self, name: &str) {

        let logger = Logger::new(LOG_FILE);

        match self.database.create_playlist(name) {
            Ok(playlist_id) => logger.debug(&format!("Created playlist '{}' with ID {}", name, playlist_id)),
            Err(e) => logger.error(&format!("Playlist '{}' already exists: {}", name, e)),
        }
    }

    pub fn delete_playlist(&mut self, playlist_id: i64) {

        let logger = Logger::new(LOG_FILE);
        match self.database.delete_playlist(playlist_id) {
            Ok(_) => logger.debug(&format!("Deleted playlist with ID {}", playlist_id)),
            Err(e) => logger.error(&format!("Error deleting playlist ID {}: {}", playlist_id, e)),
        }
    }

    pub fn add_media_to_playlist(&mut self, media_id: i64, playlist_id: i64) {

        let logger = Logger::new(LOG_FILE);

        match self.database.add_media_to_playlist(media_id, playlist_id) {
            Ok(_) => logger.debug(&format!("Media ID {} added to Playlist ID {}", media_id, playlist_id)),
            Err(e) => logger.error(&format!("Error adding Media ID {} to Playlist ID {}: {}", media_id, playlist_id, e)),
        }
    }
    
    pub fn remove_media_from_playlist(&mut self, media_id: i64, playlist_id: i64) {

        let logger = Logger::new(LOG_FILE);

        match self.database.remove_media_from_playlist(media_id, playlist_id) {
            Ok(_) => logger.debug(&format!("Media ID {} removed from Playlist ID {}", media_id, playlist_id)),
            Err(e) => logger.error(&format!("Error removing Media ID {} from Playlist ID {}: {}", media_id, playlist_id, e)),
        }
    }

    pub fn get_media_from_playlist(&mut self, playlist_id: i64) -> Vec<i64> {

        let logger = Logger::new(LOG_FILE);

        match self.database.get_media_from_playlist(playlist_id) {
            Ok(media_list) => media_list,
            Err(e) => {
                logger.error(&format!("Error retrieving media from Playlist ID {}: {}", playlist_id, e));
                Vec::new()
            }
        }
    }

    pub fn get_playlist_id(&mut self, name: &str) -> i64 {
        
        let logger = Logger::new(LOG_FILE);

        match self.database.get_playlist_id(name) {
            Ok(playlist_id) => playlist_id,
            Err(e) => {
                logger.error(&format!("Error retrieving playlist ID for '{}': {}", name, e));
                -1
            }
        }
    }

    pub fn get_all_playlists(&mut self) -> Vec<(i64, String)> {

        let logger = Logger::new(LOG_FILE);
        
        match self.database.get_all_playlists() {
            Ok(playlists) => playlists,
            Err(e) => {
                logger.error(&format!("Error retrieving playlists: {}", e));
                Vec::new()
            }
        }
    }

    pub fn add_tag(&mut self, tag_name: &str) {

        let logger = Logger::new(LOG_FILE);

        match self.database.get_or_create_tag(tag_name) {
            Ok(tag_id) => logger.debug(&format!("Tag '{}' has ID {}", tag_name, tag_id)),
            Err(e) => logger.error(&format!("Error adding tag '{}': {}", tag_name, e)),
        }
    }

    pub fn add_tag_to_media(&mut self, media_id: i64, tag_id: i64) {

        let logger = Logger::new(LOG_FILE);

        match self.database.add_tag_to_media(media_id, tag_id) {
            Ok(_) => logger.debug(&format!("Tag ID {} added to Media ID {}", tag_id, media_id)),
            Err(e) => logger.error(&format!("Error adding Tag ID {} to Media ID {}: {}", tag_id, media_id, e)),
        }
    }

    pub fn get_tag_id(&mut self, tag_name: &str) -> i64 {
        
        let logger = Logger::new(LOG_FILE);

        match self.database.get_tag_id(tag_name) {
            Ok(tag_id) => tag_id,
            Err(e) => {
                logger.error(&format!("Error retrieving tag ID for '{}': {}", tag_name, e));
                -1
            }
        }
    }

    pub fn add_source(&mut self, path: PathBuf, media_type: MediaType) {
        match media_type {
            MediaType::Audio => self.scan_lib.libraries.add_audio_source(path),
            MediaType::Video => self.scan_lib.libraries.add_video_source(path),
            MediaType::Image => self.scan_lib.libraries.add_image_source(path),
        }

        self.reload();
    }

    pub fn remove_source(&mut self, path: PathBuf, media_type: MediaType) {
        match media_type {
            MediaType::Audio => self.scan_lib.libraries.remove_audio_source(path),
            MediaType::Video => self.scan_lib.libraries.remove_video_source(path),
            MediaType::Image => self.scan_lib.libraries.remove_image_source(path),
        }

        self.reload();
    }

    pub fn get_media_from_path(&mut self, path: PathBuf) -> Vec<MediaInfo> {
        let mut result = Vec::new();

        for (_id, item) in self.items.iter() {
            if item.get_path().starts_with(path.to_str().unwrap()) {
                result.push(item.info());
            }
        }

        result
    }

    pub fn get_all_media(&self) -> Vec<MediaInfo> {
        let mut result = Vec::new();

        for (_id, item) in self.items.iter() {
            result.push(item.info());
        }

        result
    }

    pub fn get_media_by_type(&self, media_type: MediaType) -> Vec<MediaInfo> {
        let mut result = Vec::new();

        for (_id, item) in self.items.iter() {
            if item.media_type() == media_type {
                result.push(item.info());
            }
        }

        result
    }

    pub fn get_media_from_tag(&mut self, tag_id: &str) -> Vec<i64> {
        let media_list = self.database.get_media_by_tag(tag_id).unwrap();
        media_list
    }

   
    pub fn play_id(&mut self, id: i64) {

        let logger = Logger::new(LOG_FILE);

        if let Some(item) = self.items.get_mut(&id) {
            println!("Playing media ID {id}: ");
            logger.debug(&format!("Playing media ID {id}: {}", item.get_name()));
            item.init();
            item.play();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }

    pub fn pause_id(&mut self, id: i64) {

        let logger = Logger::new(LOG_FILE);

        logger.debug(&format!("Pausing media ID {id}"));
        if let Some(item) = self.items.get_mut(&id) {
            item.pause();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }

    pub fn resume_id(&mut self, id: i64) {
        let logger = Logger::new(LOG_FILE);

        if let Some(item) = self.items.get_mut(&id) {
            item.resume();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }

    pub fn stop_id(&mut self, id: i64) {
        let logger = Logger::new(LOG_FILE);

        if let Some(item) = self.items.get_mut(&id) {
            item.stop();
        } else {
            logger.error(&format!("Error: media with ID {id} not found."));
        }
    }


    pub fn info_id(&self, id: i64) -> Option<MediaInfo> {
        if let Some(item) = self.items.get(&id) {
            Some(item.info())
        } else {
            None
        }
    }

    pub fn media_type_id(&self, id: i64) -> Option<crate::media::data::MediaType> {
        if let Some(item) = self.items.get(&id) {
            Some(item.media_type())
        } else {
            None
        }
    }

    pub fn clear(&mut self) {
        println!("üî• GRAND NETTOYAGE EN COURS...");

        // 1. On vide la m√©moire RAM
        self.items.clear();
        
        // 2. On vide la Base de Donn√©es
        if let Err(e) = self.database.clear_all_media() {
            println!("‚ùå Erreur lors du nettoyage de la DB : {}", e);
        } else {
            println!("‚úÖ Base de donn√©es vid√©e.");
        }

        // 3. ON R√âINITIALISE LE SCANNER PROPREMENT
        // Au lieu de supprimer le fichier (ce qui casse tout), on l'√©crase avec un JSON vide valide.
        // Cela permet au scanner de repartir sur une base saine.
        let sources_path = Path::new("db/sources.json");
        
        // On √©crit un objet JSON vide "{}" pour ne pas faire planter le parser JSON
        if let Err(e) = fs::write(sources_path, "{}") {
             println!("‚ö†Ô∏è Impossible de r√©initialiser sources.json : {}", e);
        } else {
             println!("‚úÖ Fichier sources.json r√©initialis√© (chemins oubli√©s).");
        }

        // On recharge un scanner tout neuf qui lira ce fichier vide
        self.scan_lib = Scan::new();
    }

}



#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    struct TestMedia {
        path: String,
        name: String,
        mtype: MediaType,
        played: bool,
        paused: bool,
        resumed: bool,
        stopped: bool,
    }

    impl TestMedia {
        fn new(id: i64, path: &str, name: &str, mtype: MediaType) -> (i64, Box<dyn Media>) {
            (
                id,
                Box::new(Self {
                    path: path.into(),
                    name: name.into(),
                    mtype,
                    played: false,
                    paused: false,
                    resumed: false,
                    stopped: false,
                }),
            )
        }
    }

    impl Media for TestMedia {
        fn init(&mut self) {}
        fn play(&mut self) { self.played = true; }
        fn pause(&self) { let _ = &self.paused; }
        fn resume(&self) { let _ = &self.resumed; }
        fn stop(&self) { let _ = &self.stopped; }
        fn info(&self) -> MediaInfo {
            MediaInfo {
                id: 0,
                path: self.path.clone(),
                title: Some(self.name.clone()),
                duration: None,
                media_type: MediaType::Audio,
            }
        }
        fn media_type(&self) -> MediaType { MediaType::Audio }
        fn get_name(&self) -> String { self.name.clone() }
        fn get_path(&self) -> String { self.path.clone() }
    }

    fn test_library(items: Vec<(i64, Box<dyn Media>)>) -> MediaLibrary {
        MediaLibrary {
            items: HashMap::from_iter(items),
            scan_lib: Scan { libraries: crate::library::sources::LibraryConfig::load("db/sources.json"), scan: Vec::new() },
            database: DB { conn: rusqlite::Connection::open_in_memory().unwrap(), media_rows: Vec::new() },
        }
    }

    #[test]
    fn info_and_media_type_by_id() {
        let mut lib = test_library(vec![TestMedia::new(1, "/media/a.mp3", "Song", MediaType::Audio)]);
        assert_eq!(lib.info_id(1).unwrap().path, "/media/a.mp3");
        assert!(lib.info_id(99).is_none());
        assert_eq!(lib.media_type_id(1), Some(MediaType::Audio));
        assert_eq!(lib.media_type_id(99), None);
    }

    #[test]
    fn get_all_and_by_type() {
        let lib = test_library(vec![
            TestMedia::new(1, "/media/a.mp3", "Song", MediaType::Audio),
            TestMedia::new(2, "/media/v.mp4", "Clip", MediaType::Video),
        ]);
        let all = lib.get_all_media();
        assert_eq!(all.len(), 2);
        let audios = lib.get_media_by_type(MediaType::Audio);
        println!("audios: {:?}", audios);
        assert_eq!(audios.len(), 2);
    }

    #[test]
    fn get_media_from_path_filters_prefix() {
        let mut lib = test_library(vec![
            TestMedia::new(1, "/media/music/a.mp3", "A", MediaType::Audio),
            TestMedia::new(2, "/videos/b.mp4", "B", MediaType::Video),
        ]);
        let list = lib.get_media_from_path(PathBuf::from("/media"));
        assert_eq!(list.len(), 1);
        assert_eq!(list[0].path, "/media/music/a.mp3");
    }

    #[test]
    fn play_pause_resume_stop_do_not_panic() {
        let mut lib = test_library(vec![TestMedia::new(1, "/media/a.mp3", "Song", MediaType::Audio)]);
        lib.play_id(1);
        lib.pause_id(1);
        lib.resume_id(1);
        lib.stop_id(1);
    }

    #[test]
    fn add_media_to_playlist_handles_missing() {
        let mut lib = test_library(vec![]);
        // should not panic when ID missing
        lib.play_id(42);
        lib.pause_id(42);
        lib.resume_id(42);
        lib.stop_id(42);
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/library/mod.rs
==========================================
pub mod sources;
pub mod media_library;
==========================================
Ì≥Ñ FICHIER : ./src/library/sources.rs
==========================================

/*
This file manages media sources for the library,
loading and saving source configurations to a JSON file.
*/

use std::fs;
use serde::{Serialize, Deserialize};
use std::path::PathBuf;

use crate::constants::constants::SOURCE_FILE;

#[derive(Serialize, Deserialize, Debug)]
pub struct MediaSource {
    pub path: PathBuf,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct LibraryConfig {
    pub sources: Vec<MediaSource>,
    pub music_sources: Vec<MediaSource>,
    pub video_sources: Vec<MediaSource>,
    pub image_sources: Vec<MediaSource>,
}

impl LibraryConfig {
    pub fn load(path: &str) -> Self {
        if let Ok(data) = fs::read_to_string(path) {
           // println!("Fichier charg√© : {}", data);
            if let Ok(config) = serde_json::from_str(&data) {
                // println!("Configuration pars√©e : {:?}", config);
                return config;
            }
        }

        // Si le fichier n'existe pas ou est vide
        Self { sources: Vec::new(), music_sources: Vec::new(), video_sources: Vec::new(), image_sources: Vec::new() }
    }

    pub fn save(&self, path: &str) {
        let json = serde_json::to_string_pretty(&self).unwrap();
        fs::write(path, json).unwrap();
    }


    pub fn add_source(&mut self, folder: PathBuf) {
        if !self.sources.iter().any(|s| s.path == folder) {
            self.sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }
    pub fn add_audio_source(&mut self, folder: PathBuf) {
        if !self.music_sources.iter().any(|s| s.path == folder) {
            self.music_sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }
    pub fn add_video_source(&mut self, folder: PathBuf) {
        if !self.video_sources.iter().any(|s| s.path == folder) {
            self.video_sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }
    pub fn add_image_source(&mut self, folder: PathBuf) {
        if !self.image_sources.iter().any(|s| s.path == folder) {
            self.image_sources.push(MediaSource { path: folder });
        }
        self.save(SOURCE_FILE);
    }

        pub fn remove_source(&mut self, folder: PathBuf) {
        self.sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }


    pub fn remove_audio_source(&mut self, folder: PathBuf) {
        self.music_sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }

    pub fn remove_video_source(&mut self, folder: PathBuf) {
        self.video_sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }

    pub fn remove_image_source(&mut self, folder: PathBuf) {
        self.image_sources.retain(|s| s.path != folder);
        self.save(SOURCE_FILE);
    }

    
}









#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::time::{SystemTime, UNIX_EPOCH};

    fn temp_file(label: &str) -> String {
        let stamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        std::env::temp_dir()
            .join(format!("epikodi_sources_{label}_{stamp}.json"))
            .to_string_lossy()
            .to_string()
    }

    #[test]
    fn load_nonexistent_file_returns_empty_config() {
        let path = temp_file("nonexistent");
        let config = LibraryConfig::load(&path);
        assert_eq!(config.sources.len(), 0);
        assert_eq!(config.music_sources.len(), 0);
        assert_eq!(config.video_sources.len(), 0);
        assert_eq!(config.image_sources.len(), 0);
    }

    #[test]
    fn save_and_load_persists_config() {
        let path = temp_file("persist");
        let mut config = LibraryConfig {
            sources: vec![MediaSource { path: PathBuf::from("/media") }],
            music_sources: vec![MediaSource { path: PathBuf::from("/music") }],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.save(&path);

        let loaded = LibraryConfig::load(&path);
        assert_eq!(loaded.sources.len(), 1);
        assert_eq!(loaded.sources[0].path, PathBuf::from("/media"));
        assert_eq!(loaded.music_sources.len(), 1);
        assert_eq!(loaded.music_sources[0].path, PathBuf::from("/music"));

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_source_prevents_duplicates() {
        let path = temp_file("no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_source(PathBuf::from("/media"));
        config.add_source(PathBuf::from("/media"));

        assert_eq!(config.sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_audio_source_prevents_duplicates() {
        let path = temp_file("audio_no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_audio_source(PathBuf::from("/music"));
        config.add_audio_source(PathBuf::from("/music"));

        assert_eq!(config.music_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_video_source_prevents_duplicates() {
        let path = temp_file("video_no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_video_source(PathBuf::from("/videos"));
        config.add_video_source(PathBuf::from("/videos"));

        assert_eq!(config.video_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn add_image_source_prevents_duplicates() {
        let path = temp_file("image_no_dup");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_image_source(PathBuf::from("/images"));
        config.add_image_source(PathBuf::from("/images"));

        assert_eq!(config.image_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }

    #[test]
    #[ignore]
    fn add_source_saves_to_file() {
        let path = temp_file("save_check");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_source(PathBuf::from("/media"));

        // Verify file exists after save
        assert!(fs::metadata(&path).is_ok());

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn multiple_sources_can_coexist() {
        let path = temp_file("multi");
        let mut config = LibraryConfig {
            sources: vec![],
            music_sources: vec![],
            video_sources: vec![],
            image_sources: vec![],
        };
        config.add_audio_source(PathBuf::from("/music1"));
        config.add_audio_source(PathBuf::from("/music2"));
        config.add_video_source(PathBuf::from("/videos1"));
        config.add_image_source(PathBuf::from("/images1"));

        assert_eq!(config.music_sources.len(), 2);
        assert_eq!(config.video_sources.len(), 1);
        assert_eq!(config.image_sources.len(), 1);

        let _ = fs::remove_file(&path);
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/logger/logger.rs
==========================================
/*
logger.rs - A simple logging utility for EpiKodi
*/


use std::fs::OpenOptions;
use std::io::Write;
use chrono::Local;

use crate::constants::constants::DEBUG;

// Define the different log levels
#[derive(Debug, Clone, Copy)]
pub enum LogLevel {
    Info,
    Warning,
    Error,
    Debug,
}

impl LogLevel {
    // Convert log level to a string for display
    fn as_str(&self) -> &str {
        match self {
            LogLevel::Info => "INFO",
            LogLevel::Warning => "WARNING",
            LogLevel::Error => "ERROR",
            LogLevel::Debug => "DEBUG",
        }
    }
}

// The Logger struct
pub struct Logger {
    log_file: String,
}

impl Logger {
    // Create a new logger instance
    pub fn new(log_file: &str) -> Self {
        Logger {
            log_file: log_file.to_string(),
        }
    }

    // Main logging method
    pub fn log(&self, level: LogLevel, message: &str) {
        // Get current timestamp
        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S");
        
        // Format the log entry
        let log_entry = format!("[{}] [{}] {}\n", timestamp, level.as_str(), message);
        
        // Print to console
        print!("{}", log_entry);
        
        // Write to file
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
            .expect("Failed to open log file");
        
        file.write_all(log_entry.as_bytes())
            .expect("Failed to write to log file");
    }

    // Convenience methods for each log level
    pub fn info(&self, message: &str) {
        self.log(LogLevel::Info, message);
    }

    pub fn warning(&self, message: &str) {
        self.log(LogLevel::Warning, message);
    }

    pub fn error(&self, message: &str) {
        self.log(LogLevel::Error, message);
    }

    pub fn debug(&self, message: &str) {
        if DEBUG {
            self.log(LogLevel::Debug, message);
        }
    }
}

==========================================
Ì≥Ñ FICHIER : ./src/logger/mod.rs
==========================================
pub mod logger;
==========================================
Ì≥Ñ FICHIER : ./src/main.rs
==========================================
#![allow(non_snake_case)]

mod constants;
mod threading;
mod database;
mod media;
mod library;
mod scan;
mod config;
mod gui;
mod iptv;
mod logger;
mod plugin;

use crate::logger::logger::Logger;


use crate::gui::style::GLOBAL_STYLE;
use crate::config::AppConfig;

use crate::gui::init::{App, RELOAD_SIGNAL}; 

use std::thread;
use std::time::Duration;

use dioxus::prelude::*;
use dioxus::desktop::{Config, WindowBuilder};

use warp::Filter;
use tokio::sync::broadcast;

fn main() {
    unsafe {
        std::env::set_var("RUST_LOG", "warp=info");
        std::env::set_var("WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS", "--disable-web-security --allow-file-access-from-files --allow-running-insecure-content --autoplay-policy=no-user-gesture-required");
    }

    let (reload_tx, _) = broadcast::channel::<()>(16);
    let _ = RELOAD_SIGNAL.set(reload_tx.clone());
    let reload_tx_server = reload_tx.clone(); 

    // --- THREAD SERVEUR ---
    thread::spawn(move || {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async move {
            loop {
                let app_config = AppConfig::load();
                let server_root = app_config.media_path.clone();
                println!("üåç SERVEUR : D√©marrage sur {}", server_root);

                let mut rx = reload_tx_server.subscribe();
                let media_route = warp::path("media").and(warp::fs::dir(server_root));
                let cors = warp::cors().allow_any_origin().allow_methods(vec!["GET", "HEAD"]);
                
                let (_addr, server) = warp::serve(media_route.with(cors))
                    .bind_with_graceful_shutdown(([127, 0, 0, 1], 3030), async move {
                        let _ = rx.recv().await;
                    });

                server.await;
                tokio::time::sleep(Duration::from_millis(1000)).await;
            }
        });
    });

    // --- FEN√äTRE ---
    let window = WindowBuilder::new()
        .with_title("NeoKodi")
        .with_resizable(true)
        .with_maximized(true);

    let config_dioxus = Config::new()
        .with_window(window)
        .with_custom_head(format!(
            r#"
            <style>{}</style>
            <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
            "#, 
            GLOBAL_STYLE
        ))
        .with_disable_context_menu(false);

    LaunchBuilder::new()
        .with_cfg(config_dioxus)
        .launch(App);
}
==========================================
Ì≥Ñ FICHIER : ./src/media/audio.rs
==========================================

/*
in this file we handle audio playback
TODO: 
*/

use super::data::Media;
use super::data::MediaType;
use super::data::MediaInfo;


use rodio::{Decoder, OutputStreamBuilder, Sink};
use std::fs::File;
use std::io::BufReader;


use lofty::prelude::*;
use lofty::{read_from_path};


struct Metadata {
    title: String,
    artist: String,
    album: String,
    year: String,
    genre: String,
    duration: f32,
}

pub struct Audio {
    pub path: String,
    pub name: String,

    media_type: MediaType,
    metadata: Metadata, // make it a json

    stream: Option<rodio::OutputStream>,    
    sink: Option<Sink>,

    
}

impl Audio {
    pub fn new(path: &str, name: &str) -> Self {


        //========= METADATA ========= 
        let tagged_file = read_from_path(path)
            .expect("Failed to read tags from file");
        let tag = match tagged_file.primary_tag() {
            Some(primary_tag) => primary_tag,
            None => tagged_file.first_tag().expect("ERROR: No tags found!"),
        };
        let props = tagged_file.properties();


        Self {
            path: path.to_string(),
            name: name.to_string(),
            sink: None,
            stream: None,
            media_type: MediaType::Audio,
            metadata: Metadata {
                title: tag.title().as_deref().unwrap_or("None").to_string(),
                artist: tag.artist().as_deref().unwrap_or("None").to_string(),
                album: tag.album().as_deref().unwrap_or("None").to_string(),
                year: tag.year().map_or("None".to_string(), |y| y.to_string()),
                genre: tag.genre().as_deref().unwrap_or("None").to_string(),
                duration: props.duration().as_secs_f32(),
            },
        }
    }
}


impl Media for Audio {
    fn init(&mut self) {
        let stream = OutputStreamBuilder::open_default_stream().expect("open_default_stream error");

        let sink = Sink::connect_new(&stream.mixer());

        self.stream = Some(stream);
        self.sink = Some(sink);
    }


    fn play(&mut self) {  
        let sink = self.sink.as_ref().expect("AudioPlayer not initialized");

        let file = File::open(&self.path).expect("open file error");
        let source = Decoder::new(BufReader::new(file)).expect("decoder error");

        sink.append(source);

        sink.play();
        println!("in media play");
    }

    fn pause(&self) {
        println!("in media pause");
        if let Some(sink) = &self.sink {
            sink.pause();
        }
    }

    fn resume(&self) {
        println!("in media resume");
        if let Some(sink) = &self.sink {
            sink.play();
        }
    }

    fn stop(&self) {
        if let Some(sink) = &self.sink {
            sink.stop();
        }
    }
    

    fn info(&self) -> MediaInfo {


        //print metadata info
        println!("{}", format!(
            "Audio: {} ({})\nTitle: {}\nArtist: {}\nAlbum: {}\nYear: {}\nGenre: {}\nDuration: {:.2} seconds",
            self.name,
            self.path,
            self.metadata.title,
            self.metadata.artist,
            self.metadata.album,
            self.metadata.year,
            self.metadata.genre,
            self.metadata.duration
        ));

        MediaInfo {
            id: 0,
            path: self.path.clone(),
            title: Some(self.name.clone()),
            duration: Some(self.metadata.duration),
            media_type: MediaType::Audio,
        }


    }
    

    fn media_type(&self) -> MediaType {
        MediaType::Audio
    }

    fn get_name(&self) -> String {
        self.name.clone()
    }

    fn get_path(&self) -> String {
        self.path.clone()
    }
}







#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    fn sample_path() -> Option<String> {
        let p = Path::new("tests/data/sample.mp3");
        if p.exists() { Some(p.to_string_lossy().to_string()) } else { None }
    }

    #[test]
    fn new_reads_metadata() {
        let path = sample_path().expect("missing test audio file");
        let audio = Audio::new(&path, "Sample");
        assert_eq!(audio.media_type(), MediaType::Audio);
        assert_eq!(audio.get_path(), path);
        assert_eq!(audio.get_name(), "Sample");
    }

    #[test]
    fn init_and_play_then_stop() {
        let path = sample_path().expect("missing test audio file");
        let mut audio = Audio::new(&path, "Sample");
        audio.init();
        audio.play(); // should not panic
        audio.pause();
        audio.resume();
        audio.stop();
    }

    #[test]
    fn info_returns_media_info() {
        let path = sample_path().expect("missing test audio file");
        let audio = Audio::new(&path, "Sample");
        let info = audio.info();
        assert_eq!(info.path, path);
        assert_eq!(info.media_type, MediaType::Audio);
        assert!(info.duration.unwrap_or(0.0) >= 0.0);
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/media/data.rs
==========================================

use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub enum MediaType {
    Audio,
    Video,
    Image,
}

#[derive(Debug, Clone, PartialEq)]
pub struct MediaInfo {
    pub id: i64,
    pub path: String,
    pub title: Option<String>,
    pub duration: Option<f32>,
    pub media_type: MediaType,
}

impl MediaType {
    pub fn from_db(value: &str) -> Option<Self> {
        match value {
            "Video" => Some(MediaType::Video),
            "Audio" => Some(MediaType::Audio),
            "Image" => Some(MediaType::Image),
            _ => Some(MediaType::Image),
        }
    }

    pub fn as_db(&self) -> &'static str {
        match self {
            MediaType::Video => "video",
            MediaType::Audio => "audio",
            MediaType::Image => "image",
        }
    }
}


impl fmt::Display for MediaType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MediaType::Audio => write!(f, "Audio"),
            MediaType::Video => write!(f, "Video"),
            MediaType::Image => write!(f, "Image"),
        }
    }
}

//TODO: implement finished event handling
pub trait Media: Send + Sync {
    fn init(&mut self) {
        println!("Media initialized");
    }
    fn play(&mut self) {
        println!("Playing media");
    }
    fn pause(&self) {
        println!("Pausing media");
    }
    fn resume(&self) {
        println!("Resuming media");
    }
    fn stop(&self) {
        println!("Stopping media");
    }
    fn info(&self) -> MediaInfo;
    fn media_type(&self) -> MediaType;

    //debug
    fn get_name(&self) -> String;
    fn get_path(&self) -> String;
}

==========================================
Ì≥Ñ FICHIER : ./src/media/image.rs
==========================================
use super::data::Media;
use super::data::MediaType;
use super::data::MediaInfo;

pub struct Image {
    pub id: i64,
    pub path: String,
    pub name: String,
    pub media_type: MediaType,
}

impl Image {
    pub fn new(id: i64, path: &str, name: &str) -> Self {
        Self {
            id,
            path: path.to_string(),
            name: name.to_string(),
            media_type: MediaType::Image,
        }
    }
}

impl Media for Image {
    fn init(&mut self) {}

    fn play(&mut self) {
        println!("Displaying image (logic handled by frontend): {}", self.name);
    }

    fn pause(&self) {}
    fn resume(&self) {}
    fn stop(&self) {}

    fn info(&self) -> MediaInfo {
        MediaInfo {
            id: self.id,
            path: self.path.clone(),
            title: Some(self.name.clone()),
            duration: None,
            media_type: MediaType::Image,
        }
    }

    fn media_type(&self) -> MediaType { MediaType::Image }
    fn get_name(&self) -> String { self.name.clone() }
    fn get_path(&self) -> String { self.path.clone() }
}
==========================================
Ì≥Ñ FICHIER : ./src/media/mod.rs
==========================================
pub mod data;

pub mod video;
pub mod audio;
pub mod image;
==========================================
Ì≥Ñ FICHIER : ./src/media/video.rs
==========================================
/* src/media/video.rs */

use super::data::Media;
use super::data::MediaType;
use super::data::MediaInfo;

// On garde une structure simple pour les m√©tadonn√©es (optionnel pour l'instant)
#[derive(Clone)]
pub struct VideoMetadata {
    pub duration: f32,
    // On pourra remettre realisateur/ann√©e plus tard
}

pub struct Video {
    pub id: i64,          // <--- L'ID est l√†
    pub path: String,
    pub name: String,
    pub metadata: VideoMetadata,
}

impl Video {
    pub fn new(id: i64, path: &str, name: &str) -> Self {
        Self {
            id,
            path: path.to_string(),
            name: name.to_string(),
            metadata: VideoMetadata {
            duration: 0.0, // On laisse √† 0 pour l'instant
            }
        }
    }
}

impl Media for Video {
    fn init(&mut self) {}

    fn play(&mut self) {
        println!("GUI will play video: {}", self.name);
    }

    fn pause(&self) {}
    fn resume(&self) {}
    fn stop(&self) {}

    fn info(&self) -> MediaInfo {
        MediaInfo {
            id: self.id,
            path: self.path.clone(),
            title: Some(self.name.clone()),
            duration: Some(self.metadata.duration),
            media_type: MediaType::Video,
        }
    }

    fn media_type(&self) -> MediaType { MediaType::Video }
    fn get_name(&self) -> String { self.name.clone() }
    fn get_path(&self) -> String { self.path.clone() }
}
==========================================
Ì≥Ñ FICHIER : ./src/plugin/functions.rs
==========================================
/*


*/

use std::os::raw::c_char;

pub type GreetFunc = unsafe extern "C" fn(*const c_char) -> *mut c_char;
pub type GetArtistMetadataFunc = unsafe extern "C" fn(*const c_char) -> *mut c_char;

pub type NameFunc = unsafe extern "C" fn() -> *mut c_char;
pub type VersionFunc = unsafe extern "C" fn() -> *mut c_char;
pub type FreeStringFunc = unsafe extern "C" fn(*mut c_char);
pub type PluginTypeFunc = unsafe extern "C" fn() -> *mut c_char;
==========================================
Ì≥Ñ FICHIER : ./src/plugin/mod.rs
==========================================
pub mod plugin_manager;
pub mod functions;
==========================================
Ì≥Ñ FICHIER : ./src/plugin/plugin_manager.rs
==========================================
/*


*/


use libloading::{Library, Symbol};
use plugin_api::Plugin;
use std::os::raw::c_char;
use std::fs;
use std::path::Path;
use std::ffi::{CStr, CString};
use crate::constants::{PLUGIN_DIR, PLUGIN_EXT};


use super::functions::PluginTypeFunc;
use super::functions::GetArtistMetadataFunc;

pub struct PluginManager {
    pub metadata_libs: Vec<Library>,
}

impl PluginManager {
    pub fn new() -> Self {
        PluginManager {
            metadata_libs: Vec::new(),
        }
    }


    pub fn load_plugins(&mut self) {

        if let Ok(paths) = fs::read_dir(PLUGIN_DIR) {
            for entry in paths.flatten() {
                let path = entry.path();

                // Extension check
                let is_plugin = path
                    .extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| PLUGIN_EXT.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);
                println!("Checking plugin file: {:?}", path);

                if is_plugin {
                    let lib = match unsafe { Library::new(path) } {
                        Ok(lib) => {
                            //println!("‚úì Library loaded successfully!\n");
                            lib
                        }
                        Err(e) => {
                            //eprintln!("‚úó Failed to load library: {}", e);
                            //eprintln!("\nMake sure you've built the plugin first:");
                            //eprintln!("\nMake sure every file is a valid plugin ({})", PLUGIN_EXT);
                            continue;
                        }
                    };


                    unsafe {
                        let get_plugin_type: Symbol<PluginTypeFunc> = match lib.get(b"plugin_type\0") {
                            Ok(func) => func,
                            Err(e) => {
                                //eprintln!("‚úó Failed to load 'plugin_type' function: {} for", e);
                                continue;
                            }
                        };

                        let type_ptr = get_plugin_type();
                        let result = CStr::from_ptr(type_ptr)
                            .to_str()
                            .unwrap_or("Error: Invalid UTF-8");

                        if result == "metadata" {
                            self.metadata_libs.push(lib);
                            println!("Loaded metadata plugin.");
                        }
                    }

                }
            }
        }
    }


    pub fn get_metadata(&mut self, artist: &str) -> &str {
        let c_artist = CString::new(artist).unwrap();

        for lib in &self.metadata_libs {

            unsafe {
                let get_artist_metadata: Symbol<GetArtistMetadataFunc> = match lib.get(b"metadata\0") {
                    Ok(func) => func,
                    Err(e) => {
                        //eprintln!("‚úó Failed to load 'get_artist_metadata' function: {}", e);
                        continue;
                    }
                };

                let metadata_ptr = get_artist_metadata(c_artist.as_ptr());
                let result = CStr::from_ptr(metadata_ptr)
                    .to_str()
                    .unwrap_or("Error: Invalid UTF-8");

                    if result == "artist not found" {
                        //println!("Artist not found in this plugin, trying next if available...");
                        continue;
                    }
                    //println!("Metadata found: {}", result);
                    return result;

            }
        }
        return "artist not found";
    }


}
==========================================
Ì≥Ñ FICHIER : ./src/scan/mod.rs
==========================================
pub mod scan;
==========================================
Ì≥Ñ FICHIER : ./src/scan/scan.rs
==========================================
/*

*/

use crate::library::sources::LibraryConfig;
use crate::library::media_library::ScannedMedia;
use crate::media::data::MediaType;

use crate::constants::{SOURCE_FILE, AUDIO_EXTS, VIDEO_EXTS, IMAGE_EXTS};

use std::path::Path;
use std::fs;


pub struct Scan {
    pub libraries: LibraryConfig,
    pub scan: Vec<ScannedMedia>,
}

impl Scan {
    pub fn new() -> Self {
        Self {
            libraries: LibraryConfig::load(SOURCE_FILE),
            scan: Vec::new(),
        }
    }

    pub fn scan_libraries(&mut self) {

        //=========== SCAN SOURCES ===========

        let music_source_paths: Vec<_> = self.libraries.music_sources.iter().map(|source| source.path.clone()).collect();
        let video_source_paths: Vec<_> = self.libraries.video_sources.iter().map(|source| source.path.clone()).collect();
        let image_source_paths: Vec<_> = self.libraries.image_sources.iter().map(|source| source.path.clone()).collect();

        println!("Scanning sources ...");
        for path in music_source_paths {
            println!("Scanning: {}", path.display());
            self.scan_audio_libraries(&path);
        }
        for path in video_source_paths {
            println!("Scanning: {}", path.display());
            self.scan_video_libraries(&path);
        }
        for path in image_source_paths {
            println!("Scanning: {}", path.display());
            self.scan_image_libraries(&path);
        }
        println!("Scanning  sources end");
    }
    
    fn scan_audio_libraries(&mut self, folder: &Path) {
        if let Ok(entries) = fs::read_dir(folder) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_dir() {
                    // Recurse
                    self.scan_audio_libraries(&path);
                    continue;
                }

                // Extension check
                let is_audio = path
                    .extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| AUDIO_EXTS.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);

                if is_audio {
                    /*println!("audio file: {}", path.display());
                    self.items.insert(
                        self.items.len() as i64,
                        Box::new(Audio::new(
                            path.to_str().unwrap_or_default(),
                            path.file_name().unwrap().to_str().unwrap_or_default(),
                        )),
                    );*/
                    self.scan.push(ScannedMedia {
                        path: path.to_string_lossy().to_string(),
                        name: path
                            .file_name()
                            .unwrap()
                            .to_string_lossy()
                            .to_string(),
                        duration: 0.0, //TODO: get duration
                        media_type: MediaType::Audio,
                    });
                }
            }
        }
    }

    pub fn scan_video_libraries(&mut self, folder: &Path) {
        
        if let Ok(entries) = fs::read_dir(folder) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_dir() {
                    // Recurse
                    self.scan_video_libraries(&path);
                    continue;
                }

                let is_video = path
                    .extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| VIDEO_EXTS.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);

                if is_video {
                    /*  
                    println!("video file: {}", path.display());
                    self.items.insert(
                        self.items.len() as i64,
                        Box::new(Video::new(
                            path.to_str().unwrap_or_default(),
                            path.file_name().unwrap().to_str().unwrap_or_default(),
                        )),
                    */
                    self.scan.push(ScannedMedia {
                        path: path.to_string_lossy().to_string(),
                        name: path
                            .file_name()
                            .unwrap()
                            .to_string_lossy()
                            .to_string(),
                        duration: 0.0, //TODO: get duration
                        media_type: MediaType::Video,
                    });
                }
            }
        }
    }

    pub fn scan_image_libraries(&mut self, folder: &Path) {
        if let Ok(entries) = fs::read_dir(folder) {
            for entry in entries.flatten() {
                let path = entry.path();

                if path.is_dir() {
                    // Recurse
                    self.scan_image_libraries(&path);
                    continue;
                }

                // Extension check
                let is_image = path
                    .extension()
                    .and_then(|ext| ext.to_str())
                    .map(|ext| IMAGE_EXTS.contains(&ext.to_ascii_lowercase().as_str()))
                    .unwrap_or(false);

                if is_image {
                    /*println!("image file: {}", path.display());
                    self.items.insert(
                        self.items.len() as i64,
                        Box::new(Image::new(
                            path.to_str().unwrap_or_default(),
                            path.file_name().unwrap().to_str().unwrap_or_default(),
                        )),
                    );*/
                    self.scan.push(ScannedMedia {
                        path: path.to_string_lossy().to_string(),
                        name: path
                            .file_name()
                            .unwrap()
                            .to_string_lossy()
                            .to_string(),
                        duration: 0.0, //TODO: get duration
                        media_type: MediaType::Image,
                    });
                }
            }
        }
    }

    // pour afficher la liste des items dans la bibliotheque
    //TODO : a enlever plus tard, c'est juste pour debug
    pub fn debug_print_items(&self) {
        println!("=== Library Content start ===");

        for item in &self.scan {
            println!("{} - {} ({})", item.media_type.to_string(), item.name, item.path);
        }

        println!("=== Library Content end ===");
    }

}






#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::time::{SystemTime, UNIX_EPOCH};

    // Creates a unique temp directory for each test.
    fn temp_dir(label: &str) -> std::path::PathBuf {
        let stamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        let dir = std::env::temp_dir().join(format!("epikodi_scan_{label}_{stamp}"));
        fs::create_dir_all(&dir).unwrap();
        dir
    }

    #[test]
    fn scan_audio_libraries_collects_audio_files() {
        let dir = temp_dir("audio");
        fs::write(dir.join("song.mp3"), b"").unwrap();
        fs::write(dir.join("note.txt"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_audio_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert_eq!(scan.scan[0].media_type, MediaType::Audio);
        assert!(scan.scan[0].path.ends_with("song.mp3"));

        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn scan_video_libraries_collects_video_files() {
        let dir = temp_dir("video");
        fs::write(dir.join("movie.mp4"), b"").unwrap();
        fs::write(dir.join("readme.md"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_video_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert_eq!(scan.scan[0].media_type, MediaType::Video);
        assert!(scan.scan[0].path.ends_with("movie.mp4"));

        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn scan_image_libraries_collects_image_files() {
        let dir = temp_dir("image");
        fs::write(dir.join("cover.jpg"), b"").unwrap();
        fs::write(dir.join("doc.pdf"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_image_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert_eq!(scan.scan[0].media_type, MediaType::Image);
        assert!(scan.scan[0].path.ends_with("cover.jpg"));

        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn scan_audio_libraries_recurse_into_subdirs() {
        let dir = temp_dir("audio_nested");
        let sub = dir.join("sub");
        fs::create_dir_all(&sub).unwrap();
        fs::write(sub.join("nested.mp3"), b"").unwrap();

        let mut scan = Scan::new();
        scan.scan_audio_libraries(&dir);

        assert_eq!(scan.scan.len(), 1);
        assert!(scan.scan[0].path.ends_with("nested.mp3"));

        let _ = fs::remove_dir_all(dir);
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/threading/command.rs
==========================================

/*
This file defines commands and events for media playback control.
*/
use crate::media::data::MediaType;
use std::path::PathBuf;
use crate::media::data::MediaInfo;

pub enum Command {
    ChangeLibraryPath(PathBuf),

    AddSource(PathBuf, MediaType), // path, media type
    RemoveSource(PathBuf, MediaType), // path, media type
    Reload(),
    /*
    TODO

    RemoveSource(PathBuf), // path
    //ScanLibrary, // allows the user to rescan the library todo: add options like full scan or quick scan, 
    ajouter un fichier de config, 
    scanner seulement la premiere fois et puis tous les x jours ou sur un bouton
    ajouter des logs
    */
            

    GetMediaFromPath(PathBuf), // path
    GetAllMedia(),
    GetMediaFromType(MediaType), // media type
    GetMediaFromTag(String), // tag name
    GetMediaFromPlaylist(i64), // playlist id
    UpdateMediaState(i64, i32, f64), // media id, status, time_stop
    /*
    TODO:
    R√©cup√©ration automatique d'informations suppl√©mentaires sur les m√©dias (affiches, synopsis, note, casting) depuis des bases de donn√©es en ligne.
    */

    Play(i64), // media id
    Pause(i64), // media id 
    Resume(i64), // media id
    Stop(i64), // media id
    Info(i64), // media id
    /*
    TODO:
    Avance rapide / Retour rapide (¬±10 secondes)
    Contr√¥le du volume (0-100%)
    Barre de progression avec seek (clic pour aller √† un moment pr√©cis)
    file d'attente de lecture (playlist dynamique)
    lecture aleatoire
    repeat
    */
    //ActuaizeMedia       //if a user want to change at what time he is in a media

    AddTag(String), // tag name
    GetTagId(String), // tag name
    AddTagToMedia(i64, i64), // media_id, tag_id
    /*
    TODO:

    */
    //RemoveTag(String),

    AddPlaylist(String), // playlist name
    GetPlaylistId(String), // playlist name
    AddMediaToPlaylist(i64, i64), // media_id, playlist_id
    //LoadM3U(String),
    RemoveMediaFromPlaylist(i64, i64), // media_id, playlist_id
    DeletePlaylist(i64), // playlist_id
    GetAllPlaylists(), // returns Vec<(playlist_id, playlist_name)>
    /*
    TODO:
    delete playlist
    */

    GetArtistMetadataFromPlugin(String), // artist name

}

pub enum Event {
    Finished(i64),
    NowPlaying(i64),
    Data(String),
    Info(MediaInfo),
    IDList(Vec<i64>),
    MediaList(Vec<MediaInfo>),
    ArtistInfoReceived(String),
    M3UList(Vec<crate::iptv::parser::TVChannel>),
    PlaylistList(Vec<(i64, String)>),
}
==========================================
Ì≥Ñ FICHIER : ./src/threading/media_thread.rs
==========================================

/*
This file manages the media thread, which handles media playback commands
*/


use crate::library::media_library::MediaLibrary;
use super::command::Command;
use super::command::Event;
use crate::media::data::MediaType;

use crate::plugin::plugin_manager::PluginManager;


use crate::constants::constants::{PLAYING};

use std::thread;
use std::sync::{Arc, Mutex, mpsc};
use std::path::PathBuf;

pub fn launch_media_thread(cmd_rx: mpsc::Receiver<Command>, evt_tx: mpsc::Sender<Event>) {

    let library = Arc::new(Mutex::new(MediaLibrary::new()));
    let lib_thread = Arc::clone(&library);
    let mut plugin_manager = PluginManager::new();
    plugin_manager.load_plugins();
    
    // let media_thread =
    thread::spawn(move || {
        let mut library = lib_thread.lock().unwrap();
        library.init();


        // ----TESTS----
        //library.play_id(3);
        //library.update_media_status_and_time(1, PLAYING, 100.0);



        drop(library);

        loop {
            // TODO handle errors
            match cmd_rx.recv() {
                // le mutex se drop en sortant du scope
                
                //TODO - virer cette merde
                // this thing is a heresy.... can't stay like this
                Ok(Command::ChangeLibraryPath(path)) => {
                    println!("üîÑ RE√áU COT√â BACKEND : CHANGEMENT DE RACINE vers {:?}", path);
                    let mut library = lib_thread.lock().unwrap();

                    library.clear();

                    evt_tx.send(Event::MediaList(Vec::new())).unwrap();

                    library.add_source(path.clone(), MediaType::Video);
                    library.add_source(path.clone(), MediaType::Audio);
                    library.add_source(path, MediaType::Image);

                    evt_tx.send(Event::MediaList(library.get_all_media())).unwrap();
                }



                Ok(Command::AddSource(path, media_type)) => {
                    let mut library = lib_thread.lock().unwrap();
                    
                    library.add_source(path, media_type);
                }

                Ok(Command::RemoveSource(path, media_type)) => {
                    let mut library = lib_thread.lock().unwrap();
                    
                    library.remove_source(path, media_type);
                }

                Ok(Command::GetAllMedia()) => {
                    let library = lib_thread.lock().unwrap();
                    let media_list = library.get_all_media();
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::GetMediaFromPath(path)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let media_list = library.get_media_from_path(path);
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::GetMediaFromType(media_type)) => {
                    let library = lib_thread.lock().unwrap();
                    let media_list = library.get_media_by_type(media_type);
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::GetMediaFromTag(tag_name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let media_list = library.get_media_from_tag(&tag_name);
                    // For simplicity, we just send the count of media items found
                    evt_tx.send(Event::IDList(media_list)).unwrap();
                }

                Ok(Command::GetMediaFromPlaylist(playlist_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let media_list = library.get_media_from_playlist(playlist_id);
                    // For simplicity, we just send the count of media items found
                    evt_tx.send(Event::IDList(media_list)).unwrap();
                }

                Ok(Command::UpdateMediaState(media_id, status, time_stop)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.update_media_status_and_time(media_id, status, time_stop);
                }

                Ok(Command::Reload()) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.reload();
                    let media_list = library.get_all_media();
                    evt_tx.send(Event::MediaList(media_list)).unwrap();
                }

                Ok(Command::Play(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.play_id(id);
                    evt_tx.send(Event::NowPlaying(id)).unwrap();
                }

                Ok(Command::Pause(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.pause_id(id);
                }

                Ok(Command::Resume(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.resume_id(id);
                    evt_tx.send(Event::NowPlaying(id)).unwrap();
                }

                Ok(Command::Stop(id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.stop_id(id);
                }

                Ok(Command::Info(id)) => {
                    let library = lib_thread.lock().unwrap();
                    let info = library.info_id(id).unwrap();
                    evt_tx.send(Event::Info(info)).unwrap();
                }

                Ok(Command::AddTag(tag_name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.add_tag(&tag_name);
                }

                Ok(Command::GetTagId(tag_name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let tag_id = library.get_tag_id(&tag_name);
                    evt_tx.send(Event::Data(tag_id.to_string())).unwrap();
                }

                Ok(Command::AddTagToMedia(media_id, tag_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.add_tag_to_media(media_id, tag_id);
                }

                Ok(Command::AddPlaylist(name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.create_playlist(&name);
                }

                Ok(Command::AddMediaToPlaylist(media_id, playlist_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.add_media_to_playlist(media_id, playlist_id);
                }

                Ok(Command::DeletePlaylist(playlist_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.delete_playlist(playlist_id);
                }

                Ok(Command::RemoveMediaFromPlaylist(media_id, playlist_id)) => {
                    let mut library = lib_thread.lock().unwrap();
                    library.remove_media_from_playlist(media_id, playlist_id);
                }

                Ok(Command::GetPlaylistId(name)) => {
                    let mut library = lib_thread.lock().unwrap();
                    let playlist_id = library.get_playlist_id(&name);
                    evt_tx.send(Event::Data(playlist_id.to_string())).unwrap();
                }

                Ok(Command::GetAllPlaylists()) => {
                    let mut library = lib_thread.lock().unwrap();
                    let playlists = library.get_all_playlists();
                    // For simplicity, we just send the count of playlists found
                    evt_tx.send(Event::PlaylistList(playlists)).unwrap();
                }

                Ok(Command::GetArtistMetadataFromPlugin(name)) => {
                    let response = plugin_manager.get_metadata(name.as_str());
                    evt_tx.send(Event::Data(response.to_string())).unwrap();
                }

                Err(_) => break,
            }
        }
    });
}






#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::mpsc;
    use std::thread;
    use std::time::Duration;

    fn setup_thread() -> (mpsc::Sender<Command>, mpsc::Receiver<Event>) {
        let (cmd_tx, cmd_rx) = mpsc::channel();
        let (evt_tx, evt_rx) = mpsc::channel();

        launch_media_thread(cmd_rx, evt_tx);

        thread::sleep(Duration::from_millis(100));

        (cmd_tx, evt_rx)
    }

    #[test]
    fn test_add_source_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        let path = PathBuf::from("/test/music");
        
        cmd_tx.send(Command::AddSource(path, crate::media::data::MediaType::Audio)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_get_all_media_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetAllMedia()).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::MediaList(_)) => {},
            _ => panic!("Expected MediaList event"),
        }
    }

    #[test]
    fn test_get_media_from_path_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        let path = PathBuf::from("/test");
        
        cmd_tx.send(Command::GetMediaFromPath(path)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::MediaList(_)) => {},
            _ => panic!("Expected MediaList event"),
        }
    }

    #[test]
    fn test_get_media_from_type_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetMediaFromType(crate::media::data::MediaType::Audio)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::MediaList(_)) => {},
            _ => panic!("Expected MediaList event"),
        }
    }

    #[test]
    fn test_get_media_from_tag_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetMediaFromTag("action".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::IDList(_)) => {},
            _ => panic!("Expected IDList event"),
        }
    }

    #[test]
    fn test_get_media_from_playlist_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetMediaFromPlaylist(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::IDList(_)) => {},
            _ => panic!("Expected IDList event"),
        }
    }

    #[test]
    fn test_play_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Play(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::NowPlaying(id)) => assert_eq!(id, 1),
            _ => panic!("Expected NowPlaying event"),
        }
    }

    #[test]
    fn test_pause_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Pause(1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_resume_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Resume(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::NowPlaying(id)) => assert_eq!(id, 1),
            _ => panic!("Expected NowPlaying event"),
        }
    }

    #[test]
    fn test_stop_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Stop(1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    #[ignore]
    fn test_info_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::Info(1)).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Info(_)) => {},
            _ => panic!("Expected Info event"),
        }
    }

    #[test]
    fn test_add_tag_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddTag("favorite".to_string())).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_get_tag_id_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetTagId("action".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Data(_)) => {},
            _ => panic!("Expected Data event"),
        }
    }

    #[test]
    fn test_add_tag_to_media_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddTagToMedia(1, 1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_add_playlist_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddPlaylist("My Playlist".to_string())).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_add_media_to_playlist_command() {
        let (cmd_tx, _evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddMediaToPlaylist(1, 1)).unwrap();
        thread::sleep(Duration::from_millis(50));
        // Command processed without panic
    }

    #[test]
    fn test_get_playlist_id_command() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::GetPlaylistId("My Playlist".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Data(_)) => {},
            _ => panic!("Expected Data event"),
        }
    }

    #[test]
    fn test_thread_exits_on_channel_close() {
        let (cmd_tx, _evt_rx) = setup_thread();
        drop(cmd_tx);
        thread::sleep(Duration::from_millis(100));
        // Thread should exit gracefully
    }

    #[test]
    fn test_multiple_sequential_commands() {
        let (cmd_tx, evt_rx) = setup_thread();
        
        cmd_tx.send(Command::AddTag("action".to_string())).unwrap();
        cmd_tx.send(Command::GetTagId("action".to_string())).unwrap();
        
        match evt_rx.recv_timeout(Duration::from_secs(1)) {
            Ok(Event::Data(_)) => {},
            _ => panic!("Expected Data event"),
        }
    }
}
==========================================
Ì≥Ñ FICHIER : ./src/threading/mod.rs
==========================================
pub mod media_thread;
pub mod command;